[ { "title": "스프링 배치(Spring Batch) - 2. 스프링 배치 도메인 이해", "url": "/posts/spring-batch-2/", "categories": "Spring", "tags": "spring, batch", "date": "2023-07-27 09:00:01 +0900", "snippet": "저번 포스팅에서 스프링 배치를 구성하기 위해 필요한 준비들에 대해 알아보았다. 이번 포스팅에서는 스프링 배치에서 사용하는 주요 도메인들에 대해 알아볼 것이다. Job배치 계층 주소에서 가장 상위에 있는 개념으로 하나의 배치작업 자체를 의미한다. JobParameterJob을 실행할 때 함께 포함되어 사용되는 파라미터를 가진 객체이다. JobInstanceJob 이 실행될 때 생성되는 Job 의 논리적 실행 단위 객체이다. 만약 처음 실행하는 Job + JobParameter 일 경우 새로운 JobInstance 를 생성한다. 이미 실행한 적 있는 Job + JobParameter 일 경우 기존에 생성된 JobInstance를 리턴한다 다음은 “일별 정산”을 하는 Job 에 대해 “2021.01.01” 이라는 JobParameter 를 전달하여 실행한 경우를 도식화한 것이다. 다음날 동일 Job에 대해 “2022.01.02” 라는 JobParameter 로 실행하면 다음과 같이 BATCH_JOB_INSTANCE 테이블에 저장될 것이다. JobExecutionJobInstance 에 대한 한번의 시도를 의미하는 객체이다. 시작시간, 종료시간, 상태, 종료상태의 속성을 가진다. JobExecution 의 실행 상태가 COMPLETED 가 될 때까지 하나의 JobInstance 내에서 여러 번의 시도가 생길 수 있다.다음은 위 예제에서 살펴본 일별 정산 Job 에 대해 어떻게 JobExecution 이 생성되는지 도식화한 것이다. StepJob을 구성하는 독립적인 하나의 단계이다. Step의 종류로 JobStep, TaskletStep, FlowStep, PartitionStep 이 있다. StepExecutionStep 에 대한 한번의 시도를 의미하는 객체이다. 시작시간, 종료시간, 상태 등의 속성을 가진다. Step 이 실패할 경우 StepExecution 은 FAILED 상태가 되고 JobExecution 또한 FAILED 상태가 된다. 다음은 이러한 상황을 잘 보여준다. JobRepository배치 작업 중 발생하는 정보를 저장하는 저장소 객체이다. 배치 작업의 수행과 관련된 모든 메타데이터를 저장한다. JobLauncherJob 을 실행시키는 역할을 한다. Job 과 JobParameter 을 인자로 받아 요청된 배치 작업을 수행한 후 최종 client 에게 JobExecution 을 반환한다. Job 을 실행하는 방식으로 동기적 실행과 비동기적 실행이 있다. 비동기적 실행의 경우 실행 즉시 응답값을 반환하는 차이점이 있다. 지금까지 알아본 배치 도메인 말고도 다양한 도메인들이 있지만 주요 도메인들만 알아 보았다.다음 포스팅에서는 실제 실행 과정에 대해 알아 보자. " }, { "title": "스프링 배치(Spring Batch) - 1. 스프링 배치 시작", "url": "/posts/spring-batch/", "categories": "Spring", "tags": "spring, batch", "date": "2023-07-23 09:00:01 +0900", "snippet": "최근 업무 중 스프링 배치를 사용할 일이 있어 빠르게 사용법을 익히고 적용하게 되었다.기존에 인프런에서 강의를 사놓은 게 있어 참고하긴 했지만 너무 빠르게 익힌 감이 있어 글로 정리해 보려 한다.배치 애플리케이션이란?배치(Batch)란 일괄처리 란 뜻을 가지고 있다.만약 매일 전 날 데이터를 집계 해야한다고 가정해 보자.이 집계 과정을 기존의 웹 어플리케이션에서 수행한다면 커다란 문제가 생길 것이다.집계하는 과정에서 아주 커다란 데이터를 읽고, 가공하고, 저장하기 때문에 서버의 CPU, I/O 등의 자원을 다 써버려서[기존의 웹 어플리케이션에서 수행하던 Request 처리를 하지 못하게 될 것이다.그리고 이 집계 기능은 하루에 1번 수행된다.이를 위해 복잡한 API를 구성하는 것은 낭비라고 볼 수 있다.또한 성격이 다른 집계 기능을 추가할 때에도 비즈니스 로직 개발이 아닌 읽기, 가공하기, 저장하기 등의 기능을 개발하느라 대부분의 시간을 쓸 것이다. 그리고 만약 이 집계 기능을 수행하는 도중 실패했을 때 이를 처리하는 과정도 매우 복잡할 것이다. 5만번째에서 실패했을때 이를 skip 하고 5만1번째 데이터를 처리하도록 하고 싶어도 어려움이 있을 것이다. 또 이런 경우도 있을 수 있다. 오늘 아침 누군가가 집계 함수를 실행시켰는데, 다른 누군가가 또 실행시켜 집계 데이터가 2배로 뻥튀기 될 수도 있다. 같은 파라미터로 같은 함수를 실행할 경우 실패하도록 할 수 있다면 이를 방지할 수 있을 것이다 바로 이렇게 단발성으로 대용량의 데이터를 처리하는 어플리케이션을 배치 어플리케이션이라고 한다. 위 고민들의 공통점을 생각해보면 결국 비즈니스 로직이 아닌 배치성 기능을 처리해줄 무언가가 필요하다는 결론이 나온다.Spring 진영에서 이런 배치 어플리케이션을 지원하는 모듈로 Spring Batch가 있다. 스프링 배치 시작 - @EnableBatchProcessing스프링 배치를 시작하기 위해 의존성 설정을 해준 뒤, 가장 먼저 해야 할 것은 @EnableBatchProcessing 어노테이션 지정이다 해당 어노테이션을 지정하면 총 4개의 설정 클래스를 실행시키고 배치의 모든 초기화 및 실행 구성을 한다. 다음은 @EnableBatchProcessing 어노테이션이 실행하는 3개의 설정 클래스이다. BatchAutoConfiguration Job을 실행하는 JobLauncherApplicationRunner 빈을 생성 SimpleBatchConfiguration JobBuilderFactory, StepBuilderFactory 등 스프링 배치의 주요 구성 요소를 프록시 객체로 생성 BatchConfigurerConfiguration SimpleBatchConfiguration 에서 생성한 프록시 객체를 기반으로 실제 대상 객체를 생성 한 문장으로 @EnableBatchProcessing 어노테이션의 기능을 설명하자면 스프링 배치의 주요 구성 요소를 생성하고 빈으로 등록한 뒤 JobLauncherApplicationRunner를 실행시켜 빈으로 등록된 Job을 실행한다고 할 수 있다.스프링 배치 시작 - DB 스키마 생성스프링 배치를 위해 어노테이션을 지정한 후 또 해야할 일이 있다. 스프링 배치는 관리를 위한 목적으로 여러 도메인들 (Job, Step, JobParameter 등)의 정보들을 관리할 수 있는 스키마를 제공한다.RDBMS를 사용할 수도 있고 주로 테스트 목적으로 사용하는 인메모리 DB(H2 등)를 사용할 수도 있다.얼마 전 업무에서는 Spring Cloud Data Flow (클라우드 기능) 내부 DB에 연결에 사용하였다. 아무튼 스프링 배치 메타데이터를 저장할 DB 스키마를 생성했다면 Datasource 설정을 해야 한다. 일반적으로 Spring Batch를 사용하는 어플리케이션에서는 배치 메타데이터를 저장하는 DB 뿐만 아니라 비즈니스 로직에 사용되는 DB도 사용한다. 그렇다면 다중 DataSource 설정을 해야 할텐데 이는 배치 메타데이터 관리용 DB 설정에 @Primary 어노테이션을 붙이면 된다@Configuarationpublic class DataConfig { @Primary @Bean(name = &quot;batchDataSource&quot;) @ConfiguartionProperties(prefix = &quot;spring.datasource.batch&quot;) public DataSource batchDataSource() { return DataSourceBuilder.create.build(); } @Bean(name = &quot;oracleDataSource&quot;) @ConfiguartionProperties(prefix = &quot;spring.datasource.oracle&quot;) public DataSource oracleDataSource() { return DataSourceBuilder.create.build(); }}여기까지 진행했다면 이제 본격적으로 배치 구성 요소를 만들 준비가 된 것이다.다음 포스팅에서는 Job, Step 등 배치 구성 요소들을 살펴 보자." }, { "title": "예제로 알아보는 제어의 역전 - IoC(Inversion of Control)", "url": "/posts/ioc/", "categories": "Spring", "tags": "spring, ioc", "date": "2023-06-22 09:00:01 +0900", "snippet": "스프링 프레임워크에 대해 공부하다 보면 IoC, 제어의 역전이라는 키워드가 자주 등장한다.스프링을 사용하는 개발자라면 숨쉬듯이 사용하고 있을 이 개념을 예제를 통해 다시 한번 정리해 보려고 한다.IoC란? 프로그램의 제어 권한을 자신이 아닌 다른 대상에게 위임하는 방식추상적인 개념이기에 한 문장으로 표현하기가 어렵다. 따라서 폭넓게 적용되어 있는 다양한 예시를 들어 살펴보자.1. 서블릿일반적인 자바 프로그램은 main() 메소드에서 시작해서 개발자가 미리 정한 순서를 따라 오브젝트가 생성되고 실행된다.그런데 서블릿을 개발해 서버에 배포할 수는 있지만, 그 실행을 개발자가 직접 제어할 수 있는 방법은 없다.대신 서블릿에 대한 제어 권한을 가진 서블릿 컨테이너가 적절한 시점에 서블릿 클래스의 오브젝트를 만들고 그 안의 메소드를 호출한다.정리하자면 서블릿의 제어 권한을 자신이 아닌 서블릿 컨테이너에게 위임했다고 볼 수 있다.2. 템플릿 메소드 패턴디자인 패턴 중 템플릿 메소드 패턴도 제어의 역전 개념을 사용하는 대표적인 사례이다.템플릿 메소드 패턴은 변하지 않는 기능은 슈퍼클래스에 만들어두고 자주 변경되며 확장할 기능은 서브클래스에서 만들도록 하는 것이다.다음 템플릿 메소드 패턴이 적용된 DAO를 통해 제어의 역전이 적용된 사례를 살펴보자public abstract class UserDao { public void add(User user) throws ClassNotFoundException, SQLException { Connection c = getConnection(); // 사용자 추가 로직 } public void get(String id) throws ClassNotFoundException, SQLException { Connection c = getConnection(); // 사용자 조회 로직 } public abstract Connection getConnection() throws ClassNotFoundException, SQLException{};}위 예제를 보면 추상 UserDao를 상속한 서브클래스는 getConnection()을 구현한다.하지만 서브클래스는 getConnection()에 대한 제어권을 가지지 않는다.정리하자면 getConnection()의 제어 권한을 자신이 아닌 상위 템플릿 메소드(add, get 등)에게 위임 했다고 볼 수 있다. 3. 스프링 프레임워크프레임워크 또한 제어의 역전 개념이 적용된 대표적인 기술이다.애플리케이션 코드는 직접 실행되지 않고 프레임워크에 의해 사용된다.보통 프레임워크 위에 개발한 클래스를 등록해두고, 프레임워크가 흐름을 주도하는 중 개발자가 만든 애플리케이션 코드를 사용하도록 만든다.정리하자면 애플리케이션 코드의 제어 권한을 자신이 아닌 프레임워크에게 위임했다고 볼 수 있다.4. 애플리케이션 컨텍스트빈의 생명주기를 관리하며 의존관계를 맺어주는 애플리케이션 컨텍스트 또한 제어의 역전 개념이 적용된다.DI를 사용하는 다음 예제를 보자.public class UserDao{ @Autowired Connection connection; public void add(User user) throws ClassNotFoundException, SQLException { // ... PreparedStatement ps = connection.prepareStatement( &quot;insert into users(id, name, password) values(?,?,?)&quot;); // ... }}add() 메소드는 직접 커넥션을 만들어 사용하지 않고 @Autowired 애노테이션을 통해 컨테이너에 등록된 빈을 사용한다.정리하자면 빈의 생성 및 생명주기 관리에 대한 제어 권한을 자신이 아닌 애플리케이션 컨텍스트에 위임했다고 볼 수 있다.IoC의 장점그렇다면 IoC를 사용함으로써 얻을 수 있는 장점이 무엇이기에 이렇게 많은 곳에서 사용하는 걸까?그것은 각 오브젝트들의 관심과 책임을 분리하여 다양한 환경에 효과적으로 대응할 수 있기 때문일 것이다.위 4번 예제에서 직접 커넥션을 생성하고 사용한다고 가정하자.요구사항이 변하여 다른 DB를 사용해야 한다면 소스코드를 수정해야 할 것이다.하지만 IoC를 적용한 애플리케이션 컨텍스트를 사용한다면 커넥션의 생성을 고민하지 않아도 될 것이다." }, { "title": "스프링 MVC", "url": "/posts/spring-mvc/", "categories": "Spring", "tags": "spring, spring mvc", "date": "2023-06-07 09:00:01 +0900", "snippet": "저번 포스팅에서 서블릿 컨테이너, 스프링 컨테이너의 생성 과정을 알아 보았다.이번 포스팅에서는 MVC 아키텍쳐에서 각 컨테이너들의 생성 이후 사용자의 요청을 처리하는 과정을 알아 본다.MVC 아키텍쳐란? 프레젠테이션 계층의 구성요소를 정보를 담은 모델(M), 화면 출력 로직을 담은 뷰(V), 제어 로직을 담은 컨트롤러(C) 로 분리하고이 세 가지 요소가 서로 협력하여 하나의 웹 요청을 처리하고 응답을 만들어내는 구조다.일반적으로 MVC 아키텍쳐는 프론트 컨트롤러 패턴과 함께 사용된다.프론트 컨트롤러 패턴은 중앙집중형 컨트롤러를 프레젠테이션 계층의 제일 앞에 둬서 서버로 들어오는 모든 요청을 먼저 받아 처리한다.DispatcherServlet과 MVC의 동작 과정MVC의 각 요소와 프론트 컨트롤러가 어떻게 협력하여 일하는지 파악하고 있어야 복잡한 웹 프레젠테이션 계층의 로직을 구현할 수 있다.서버가 브라우저나 여타 HTTP 클라이언트로부터 HTTP 요청을 받기 시작해서 다시 HTTP로 결과를 응답해주기까지의 과정을 살펴보자.1. DispatcherServlet의 HTTP 요청 접수저번 시간에 알아본 서블릿 컨테이너는 HTTP 프로토콜을 통해 들어오는 요청이 DispatcherServlet에 할당된 것이라면HTTP 요청정보를 DispatcherServlet에 전달해준다.DispatcherServlet은 web.xml에 작성된 서블릿-매핑 정보를 기반으로 자신이 전달받을 URL 패턴이라면등록된 전처리 작업(보안, 파라미터 조작, 한글 디코딩 등)을 수행한다.2. 컨트롤러로 HTTP 요청 위임DispatcherSerlet은 HTTP 요청 정보(URL, 파라미터 등)를 참고해 어떤 컨트롤러에 작업을 위임할지 결정한다.컨트롤러를 선정하는 것은 DispatcherServlet의 핸들러 매핑 전략을 이용한다.어떤 컨트롤러가 요청을 처리하게 할지를 결정했다면, 다음은 해당 컨트롤러의 메소드를 호출해 웹 요청을 처리하도록 해야한다.그렇다면 DispatcherServlet은 호출할 각 컨트롤러의 정보를 다 알고 있어야 할까?그렇지 않다. 컨트롤러를 호출할 때에는 다음과 같이 해당 컨트롤러의 타입을 지원하는 어댑터를 중간에 껴서 호출한다.DispatcherServlet이 핸들러 어댑터에 웹 요청을 전달할 때는 요청 정보가 담긴 HttpServletRequest 오브젝트를 전달한다.이를 어댑터가 적절히 변환하여 컨트롤러 메소드가 받을 수 있는 파라미터로 전달해주는 것이다.3. 컨트롤러의 모델 생성컨트롤러는 사용자 요청을 해석하고 실제 비즈니스 로직을 수행할 서비스 계층 오브젝트에 작업을 위임한다.그리고 모델을 생성해 서비스 계층 오브젝트의 작업 결과를 넣어준다.4. 컨트롤러의 모델, 뷰 리턴모델을 생성하고 나서, 뷰를 결정해야 한다. 컨트롤러가 뷰를 직접 전달할수도 있지만, 보통은 뷰의 논리적인 이름을 리턴해주면DispatcherServlet의 전략인 뷰 리졸버가 이를 이용해 뷰를 생성해준다.모델과 뷰를 생성해 DispatcherServlet에 넘겨주고 나면, 컨트롤러의 책임은 끝이다.5. 뷰에 모델 전달DispatcherServlet은 뷰 오브젝트에 모델을 전달하고 클라이언트에 돌려줄 최종 결과물을 생성해달라고 요청한다.6. 결과물 생성 및 전달뷰는 전달된 모델의 정보를 참고하여 결과물을 동적으로 생성한다. 결과물은 HTML 이외에도 엑셀, PDF 등이 될 수 있다.생성된 결과물은 HttpServletResponse에 담겨 DispatcherServlet에 전달된다.7. DispatcherServlet의 HTTP 응답 전달뷰 생성까지의 모든 작업을 마쳤으면 DispatcherServlet은 등록된 후처리기가 있는지 확인하고,후처리기가 있다면 처리를 진행한 후에 뷰가 만들어준 HttpServletResponse를 서블릿 컨테이너에 전달한다.서블릿 컨테이너는 HttpServlet에 담긴 정보를 HTTP 응답으로 만들어 클라이언트에 전달하고 작업을 종료한다." }, { "title": "스프링 컨테이너와 서블릿 컨테이너", "url": "/posts/spring-container/", "categories": "Spring", "tags": "spring, spring container, servlet container", "date": "2023-06-06 09:00:01 +0900", "snippet": "웹 개발자라면 스프링 컨테이너와 서블릿 컨테이너에 대해 어느 정도는 알고 있을 것이다.나도 딱 어느정도만 알고 있고, 실무에서 직접적으로 다루지는 않다 보니 공부를 해도 금세 휘발되어 버린다.웹개발자라면 컨테이너, 스프링 컨테이너, 서블릿 컨테이너에 대해 언제나 설명할 수 있어야 한다고 생각하기에 정리해본다.서블릿이란? 서블릿(Servlet)이란 동적 웹 페이지를 만들 때 사용되는 자바 기반의 웹 애플리케이션 프로그래밍 기술이다.즉 정적인 웹사이트를 사용자나 요청에 따라 동적인 웹사이트로 바꿀 수 있게 도와주는 기술이다.쉽게 예를 들면 사용자의 로그인 요청을 처리하여 사용자마다 다른 웹 페이지를 보여주는 것이 바로 서블릿이다.서블릿 컨테이너란? 서블릿의 생성, 실행, 소멸 등 서블릿의 생명주기를 관리하는 컨테이너이다.웹서버와 서블릿이 쉽게 통신할 수 있도록 소켓을 만들고 listen, accept 등의 API 를 제공하여 웹서버와의 통신을 지원 한다.또한 새로운 요청이 올 때마다 새로운 자바 쓰레드를 생성하고 Http Service() 실행 후 자동 소멸하여 멀티스레드를 관리 한다.스프링 컨테이너란? 스프링 빈의 생성, 실행, 소멸 등 스프링 빈의 생명주기를 관리하는 컨테이너다.스프링 빈의 생명주기를 관리하는 것 뿐만 아니라 의존관계를 주입(Dependency Injection)하는 아주 중요한 일도 수행한다.웹 어플리케이션의 컨테이너 구조 및 동작 과정스프링 웹 기술은 MVC 아키텍쳐를 근간으로 하고 있다.MVC 아키텍쳐의 경우 제일 앞에 하나의 서블릿 컨테이너를 두고 그 뒤에 스프링 컨테이너를 두는 다음과 같은 구조를 가진다.그렇다면 이러한 구조에서 톰캣과 같은 WAS에 웹 어플리케이션이 올라가 구동되는 과정을 살펴보자. 웹 어플리케이션이 실행되면 톰캣은 DispatcherServlet 설정이 담긴 web.xml 설정을 load 한다 web.xml에 등록되어 있는 ContextLoaderListener를 Servlet Container에 생성한다 ContextLoaderListener는 MVC의 Model 설정이 담긴 root-context.xml 설정을 load 한다 root-context.xml에 등록되어 있는 스프링 빈들을 Spring Container(Root)에 생성한다 사용자의 요청이 들어온다 web.xml에 등록되어 있는 DispatcherServlet을 Servlet Container에 생성한다. DispatcherServlet은 MVC의 View 설정이 담긴 servlet-context.xml 설정을 load 한다 servlet-context.xml에 등록되어 있는 컨트롤러들을 두번째 Spring Container에 생성한다.이후 생성된 MVC 아키텍쳐이 서로 협업하여 요청을 처리하게 되고 이 과정은 다음 포스팅에 작성해보도록 하겠다." }, { "title": "자바 쓰레드 로컬(ThreadLocal)", "url": "/posts/java-threadlocal/", "categories": "Java", "tags": "java, threadlocal", "date": "2022-01-24 09:00:01 +0900", "snippet": "ThreadLocal?ThreadLocal은 해당 쓰레드만 접근할 수 있는 특별한 저장소를 말한다.쉽게 이야기해서 물건 보관 창구를 떠올리면 된다.여러 사람이 같은 물건 보관 창구를 사용하더라도 창구 직원은 사용자를 인식해서 사용자별로 확실하게 물건을 구분해준다.이해하기 쉽도록 예시를 들어 보겠다.ThreadLocal이 아닌 필드 변수를 사용할 경우 threadA가 필드 변수에 userA라는 값을 저장한다 threadB가 필드 변수에 userB라는 값을 저장한다이후 threadA가 필드 변수에 저장된 값을 불러온다면 userA가 아닌 userB값이 불러질 것이다ThreadLocal을 사용할 경우 threadA가 쓰레드 로컬에 userA라는 값을 저장한다 threadB가 쓰레드 로컬에 userB라는 값을 저장한다 이후 쓰레드 로컬을 사용하는 쓰레드에 따라 저장된 값을 다르게 불러온다ThreadLocal 사용 주의사항ThreadLocal에 저장된 값을 사용 후 제거하지 않고 그냥 두면 WAS처럼 쓰레드 풀을 사용하는 경우 심각한 문제가 발생할 수 있다.다음 예시를 통해 알아보자.1. 사용자A 저장 요청 사용자A가 저장을 요청한다 쓰레드 풀에서 쓰레드를 하나 조회한다 threadA를 할당한다 threadA는 쓰레드 로컬에 사용자A를 저장한다 쓰레드 로컬은 threadA 전용 보관소에 사용자A를 저장한다2. 사용자A 저장 요청 종료 WAS에서 사용자에게 요청에 대한 응답 threadA 반환(아직 쓰레드 로컬에 사용자A 정보가 남아있음)3. 사용자B 조회 요청 사용자B가 조회를 요청한다 쓰레드 풀에서 쓰레드를 하나 조회한다 threadA를 할당한다 threadA는 쓰레드 로컬에 저장된 사용자를 조회한다 쓰레드 로컬은 threadA 전용 보관소에서 사용자A를 응답한다 threadA는 사용자A를 전달받는다 사용자B에게 사용자A를 응답한다결론결과적으로 사용자B는 사용자A의 데이터를 확인하게 되는 심각한 문제가 발생하게 된다.이런 문제를 예방하려면 사용자A의 요청이 끝날 때 쓰레드 로컬의 값을 ThreadLocal.remove()를 통해 꼭 제거해야 한다." }, { "title": "자바 JVM(Java Virtual Machine), 가비지 콜렉션(Garbage Collection)", "url": "/posts/java-jvm/", "categories": "Java", "tags": "java, jvm, gc", "date": "2021-12-05 09:00:01 +0900", "snippet": "##JVM?JVM은 ‘java virtual machine’을 줄인 것으로 직역하면 자바를 실행하기 위한 가상 머신이라고 할 수 있다자바로 작성된 어플리케이션은 모두 이 JVM 위에서만 실행되므로, 자바 어플리케이션이 실행되기 위해서는 반드시 JVM이 필요하다일반 애플리케이션의 코드는 OS만 거치고 하드웨어로 전달되는데Java 어플리케이션은 JVM을 한번 더 거치기 때문에, 그리고 기계어로 컴파일되는 것이 아니고 실행 시 해석하는 상태이기 때문에속도가 느리다는 단점을 가지고 있다하지만 요즘엔 바이트코드를 하드웨어의 기계어로 변환해주는 JIT 컴파일러와 향상된 최적화 기술이 적용되어 속도의 격차를 많이 줄였다일반 어플리케이션은 OS 위에서 바로 동작하므로 OS에 종속적이지만, JAVA 기반 어플리케이션은 JVM 위에서 동작하므로 독립적이다하지만 반대로 JVM은 OS에 종속적이기 때문에 OS별 JVM을 따로 사용해야 한다정리하자면 Java 프로그램은 기계어가 아닌 바이트코드로 컴파일되며 JVM을 거치기 때문에 속도가 느리다는 단점을 가진다 (나중에 최적화) 자바 프로그램은 JVM을 거쳐 동작하므로 OS에 독립적이다 (JVM은 OS에 종속적)JVM의 메모리구조 메서드 영역(Method Area): 클래스 파일(.class)의 정보를 저장하는 곳 힙 (heap): 인스턴스가 생성되는 곳 호출 스택 (Call Stack): 메서드 호출 시 필요한 메모리를 제공(지역 변수)가비지 콜렉션자바는 작성된 프로그램이 실행되면, 가비지 콜렉터(garbage collector)가 자동적으로 메모리를 관리해 주기 때문에프로그래머는 메모리를 따로 관리를 하지 않아도 된다. 그렇다면 가비지 콜렉터는 어떤 방식으로 이를 처리할까? Heap의 오브젝트 중에 Stack에서 도달 불가능한 것이 가비지 콜렉션의 대상이 된다예를 들어 반복문 내부에서 생성된 인스턴스의 경우 매 반복마다 생성되고 다시 사용되지 않는 것들이 생긴다이러한 객체들이 바로 가비지 콜렉션의 대상인 것이다" }, { "title": "데이터베이스 정규화(Normalization)", "url": "/posts/db-normalization/", "categories": "Database", "tags": "db, normalization", "date": "2021-12-05 09:00:01 +0900", "snippet": "정규화정규화의 기본 목표는 테이블 간의 중복된 데이터를 허용하지 않는것이다.중복된 데이터를 허용하지 않음으로서 무결성을 유지할 수 있고, DB의 저장 용량 또한 줄일 수 있다.이러한 테이블을 분해하는 정규화 단계가 정의되어 있는데, 각 단계를 알아보자제 1정규화제 1정규화란 컬럼이 Atomic Value를 갖도록 하는 분해하는 것이다 이름 취미 코지 인터넷,게임 판다 인터넷,음악 위 테이블에서 취미라는 컬럼은 한개 이상의 값을 가지고 있다.여기에 제 1정규화를 적용하면 다음과 같은 표를 얻는다 이름 취미 코지 인터넷 코지 게임 판다 인터넷 판다 음악 제 2정규화제 2정규화란 기본키의 부분집합이 결정자가 되지 않도록 분해하는 것이다다음과 같은 테이블이 있다고 가정하자 학교 이름 취미 학교 위치 숭실대 코지 코딩 서대문구 경희대 코지 독서 동대문구 숭실대 판다 인터넷 서대문구 경희대 판다 음악 동대문구 여기서 기본키는 (학교, 이름)을 복합키로 가지고 있다.모든 컬럼이 Atomic한 값을 가지고 있지만, 기본키의 부분집합(학교)이 학교 위치를 결정하는 결정자가 된다따라서 이를 정규화하면 다음과 같다 학교 학교 위치 숭실대 서대문구 경희대 동대문구 학교 이름 취미 숭실대 코지 코딩 경희대 코지 독서 숭실대 판다 인터넷 경희대 판다 음악 제 3정규화제 3 정규화란 A-&amp;gt;B 이고 B-&amp;gt;C 일때, A-&amp;gt;C가 성립되지 않도록 분해하는 것이다 구매자 물건 가격 코지 노트북 100 판다 노트북 100 곰 데스크탑 50 여우 노트 1 위 테이블에서 구매자가 물건을 구매하고, 물건은 가격을 가지므로 이를 정규화 할 수 있다 구매자 물건 코지 노트북 판다 노트북 곰 데스크탑 여우 노트 물건 가격 노트북 100 데스크탑 50 노트 1 " }, { "title": "스프링 서비스 추상화(Service Abstraction)", "url": "/posts/spring-service-abstraction/", "categories": "Spring, Core", "tags": "spring, service abstraction, abstraction", "date": "2021-12-02 09:00:01 +0900", "snippet": "" }, { "title": "예제로 알아보는 스프링 템플릿(Template), 콜백(Callback)", "url": "/posts/spring-template/", "categories": "Spring, Core", "tags": "spring, template", "date": "2021-12-01 09:00:01 +0900", "snippet": "이전에 작성했던 DB 커넥션 코드들 중 UserDao의 가장 단순한 메서드인 deleteAll()를 살펴보자public class UserDao{ public void deleteAll() throws SQLException{ Connection c = dataSource.getConnection(); PreparedStatement ps = c.preparedStatement(&quot;delete from users&quot;); ps.executeUpdate(); ps.close(); c.close(); }}이 메서드에서는 공유 리소스인 Connection 과 PreparedStatement 자원을 가져와 사용한다이는 이미 만들어놓은 리소스 풀에서 가져와 사용하는 것이기 때문에 다 사용한 후 반납을 해 주어야 한다반납이 이루어지지 않고 계속 요청이 반복되면 요청을 처리하지 못하고 결국 서비스가 중단될 것이다따라서 우리는 이러한 예외 사항을 고려하여 코드를 수정해야 할 것이다다음은 이를 고려해 수정한 코드이다public class UserDao{ public void deleteAll() throws SQLException{ Connection c = null; PreparedStatement ps = null; try{ c = dataSource.getConnection(); ps = c.preparedStatement(&quot;delete from users&quot;); ps.executeUpdate(); }catch(SQLException e){ throw e; }finally { if (c != null) { try{ c.close(); } catch (SQLException e) { } } if (ps != null) { try{ ps.close(); } catch(SQLException e){ } } } } public void getCount() throws SQLException { Connection c = null; PreParedStatement ps = null; ResultSet rs = null; try{ c = dataSource.getConnection(); ps = c.preparedStatement(&quot;select count(*) from users&quot;); rs = ps.executeQuery(); rs.next(); return rs.getInt(1); } catch (SQLException e) { throw e; } finally { if (rs != null) { try{ rs.close(); } catch(SQLException e){ } } if (ps != null) { try{ ps.close(); } catch(SQLException e){ } } if (c != null) { try{ c.close(); } catch(SQLException e){ } } } }}당장 문제는 해결된 것처럼 보인다하지만 코드가 너무 복잡하며 중복되는 코드들이 너무 많아 실수가 발생하기 딱 좋다이제 이 문제를 해결해 보자변하는 것과 변하지 않는 것의 분리만약 로직에 따라 변하는 부분을 변하지 않는 나머지 코드에서 분리할 수 있다면 어떨까?변하지 않는 부분을 재사용할 수 있지 않을까?메소드 추출먼저 생각해 볼 수 있는 것은 변하는 부분을 메소드로 추출하는 것이다원래 변하지 않는 부분을 추출해야 하지만, 변하는 부분을 변하지 않는 부분이 감싸고 있으므로 반대로 해본 것이다public class UserDao{ public void deleteAll() throws SQLException{ Connection c = null; PreparedStatement ps = null; try{ c = dataSource.getConnection(); // ps = c.preparedStatement(&quot;delete from users&quot;); ps = makeStatement(c); ps.executeUpdate(); }catch(SQLException e){ throw e; }finally { if (c != null) { try{ c.close(); } catch (SQLException e) { } } if (ps != null) { try{ ps.close(); } catch(SQLException e){ } } } } public PreparedStatement makeStatement(Connection c) { return c.preparedStatement(&quot;delete from users&quot;); }}변하는 부분을 추출해 보았더니 당장은 별 이득이 없어 보인다보통 분리시킨 메서드를 다른 곳에서 재사용할 수 있어야 하는데, 이건 반대로 분리시키고 남은 메서드가 재사용이 필요하다이번엔 다른 방법으로 시도해보자템플릿 메소드 패턴의 적용템플릿 메소드 패턴이란 변하지 않는 부분을 슈퍼클래스에 두고 변하는 부분을 추상 메소드로 정의해서서브클래스에서 오버라이드하여 새롭게 정의해 쓰도록 하는 것이다이를 활용하면 다음과 같이 수정할 수 있을 것이다public class DeleteAllUserDao extends UserDao{ public void deleteAll() throws SQLException{ Connection c = null; PreparedStatement ps = null; try{ c = dataSource.getConnection(); // ps = c.preparedStatement(&quot;delete from users&quot;); ps = makeStatement(c); ps.executeUpdate(); }catch(SQLException e){ throw e; }finally { if (c != null) { try{ c.close(); } catch (SQLException e) { } } if (ps != null) { try{ ps.close(); } catch(SQLException e){ } } } } public abstract PreparedStatement makeStatement(Connection c) throws SQLException;}이제 업데이트와 관련된 메소드를 사용할 때마다 상속을 통해 makeStatement 메소드만 작성해 주면 될 것이다이제 OCP의 원칙을 지키는 괜찮은 코드가 완성된 것 같다하지만 이 코드에도 단점이 존재한다가장 큰 문제는 DAO 로직마다 새로운 클래스를 만들어야 한다는 점이다만약 로직이 4개라면 총 4개의 서브클래스를 만들어 사용해야 한다그렇다면 이번엔 다른 방법으로 수정해 보자전략 패턴의 적용OCP를 잘 지키면서 템플릿 메소드 패턴보다 유연하고 확장성이 뛰어난 것이 바로 전략 패턴이다전략 패턴이란, 오브젝트를 아예 둘로 분리하고, 클래스 레벨에서는 인터페이스를 통해서만 의존하도록 만드는 방법이다이를 적용한 코드를 살펴보자public interface StatementStrategy { public PreparedStrategy makePreparedStrategy(Connection c) throws SQLException;}public class DeleteAllStatementStrategy implements StatementStrategy { @Override public PreparedStrategy makePreparedStrategy(Connection c) throws SQLException { return c.prepareStatement(&quot;delete from users&quot;); }}public class UserDao { public void deleteAll() throws SQLException { Connection c = null; PreparedStatement ps = null; try { c = dataSource.getConnection(); StatementStrategy strategy = new DeleteAllStatementStrategy(); ps = strategy.makePreparedStatement(c); ps.executeUpdate(); } catch (SQLException e) { throw e; } finally { if (c != null) { try { c.close(); } catch (SQLException e) { } } if (ps != null) { try { ps.close(); } catch (SQLException e) { } } } }}전략 패턴을 적용함으로써 낮은 결합력을 갖게 되었다하지만 이 코드에도 큰 문제가 있다로직의 클라이언트인 UserDao에서 구체적인 전략인 DeleteAllStatementStrategy 클래스를 알고 있어야 한다이는 OCP에도 맞지 않고 IoC에도 맞지 않다고 할 수 있다이를 해결하려면 전략을 외부에서 주입하도록 하면 될 것이다public interface StatementStrategy { public PreparedStrategy makePreparedStrategy(Connection c) throws SQLException;}public class DeleteAllStatementStrategy implements StatementStrategy { @Override public PreparedStrategy makePreparedStrategy(Connection c) throws SQLException { return c.prepareStatement(&quot;delete from users&quot;); }}public class UserDao { public void deleteAll() throws SQLException{ StatementStrategy strategy = new DeleteAllStatementStrategy(); jdbcContextWithStatementStrategy(strategy); } public void jdbcContextWithStatementStrategy(StatementStrategy stmt) throws SQLException { Connection c = null; PreparedStatement ps = null; try { c = dataSource.getConnection(); ps = stmt.makePreparedStatement(c); ps.executeUpdate(); } catch (SQLException e) { throw e; } finally { if (c != null) { try { c.close(); } catch (SQLException e) { } } if (ps != null) { try { ps.close(); } catch (SQLException e) { } } } }}이제 동일한 전략으로 add 메서드를 작성해보자public interface StatementStrategy { public PreparedStrategy makePreparedStrategy(Connection c) throws SQLException;}public class AddStatementStrategy implements StatementStrategy { private User user; public AddStatementStrategy(User user) { this.user = user; } @Override public PreparedStrategy makePreparedStrategy(Connection c) throws SQLException { PreparedStatement ps = c.preparedStatement(&quot;insert into users(id, name, password) values(?,?,?)&quot;); ps.setString(1, user.getId()); ps.setString(2, user.getName()); ps.setString(3, user.getPassword()); return ps; }}public class UserDao { public void add(User user) throws SQLException{ StatementStrategy strategy = new AddStatementStrategy(user); jdbcContextWithStatementStrategy(strategy); } public void jdbcContextWithStatementStrategy(StatementStrategy stmt) throws SQLException { Connection c = null; PreparedStatement ps = null; try { c = dataSource.getConnection(); ps = stmt.makePreparedStatement(c); ps.executeUpdate(); } catch (SQLException e) { throw e; } finally { if (c != null) { try { c.close(); } catch (SQLException e) { } } if (ps != null) { try { ps.close(); } catch (SQLException e) { } } } }}아직 아쉬움이 남는 부분이 있다모든 statement 마다 새로운 클래스를 생성해야 하고, 클래스 파일이 점점 늘어날 것이다따라서 이를 해결하기 위해 클래스를 로컬 클래스로 변경해 보자public interface StatementStrategy { public PreparedStrategy makePreparedStrategy(Connection c) throws SQLException;}public class UserDao { public void add(Final User user) throws SQLException{ public class AddStatementStrategy implements StatementStrategy { @Override public PreparedStrategy makePreparedStrategy(Connection c) throws SQLException { PreparedStatement ps = c.preparedStatement(&quot;insert into users(id, name, password) values(?,?,?)&quot;); ps.setString(1, user.getId()); ps.setString(2, user.getName()); ps.setString(3, user.getPassword()); return ps; } } StatementStrategy strategy = new AddStatementStrategy(user); jdbcContextWithStatementStrategy(strategy); }}add 메서드 내부에 로컬 클래스로 선언하여 클래스 파일이 늘어나는 것을 방지했다또한 파라미터로 전달된 User 클래스를 Final로 선언하므로써 UserDao 내부에 불필요한 User객체 선언을 방지할 수 있게 되었다AddStatementStrategy 클래스는 UserDao의 add 메서드에서만 사용하기 때문에 익명 함수로 바꿀 수 있다더 줄여서 표현하면 다음과 같다public interface StatementStrategy { public PreparedStrategy makePreparedStrategy(Connection c) throws SQLException;}public class UserDao { public void add(Final User user) throws SQLException { jdbcContextWithStatementStrategy(new StatementStrategy() { @Override public PreparedStrategy makePreparedStrategy(Connection c) throws SQLException { PreparedStatement ps = c.preparedStatement(&quot;insert into users(id, name, password) values(?,?,?)&quot;); ps.setString(1, user.getId()); ps.setString(2, user.getName()); ps.setString(3, user.getPassword()); return ps; } }); }}이제 UserDao 외부 클래스에서도 사용할 수 있도록 jdbcContextWithStatementStrategy 메서드를 외부로 분리해보자public class JdbcContext { private DataSource dataSource; public void setDataSource(DataSource dataSource) { this.dataSource = dataSource; } public void workWithStatementStrategy(StatementStrategy stmt) throws SQLException { Connection c = null; PreparedStatement ps = null; try { c = dataSource.getConnection(); ps = stmt.makePreparedStatement(c); ps.executeUpdate(); } catch (SQLException e) { throw e; } finally { if (c != null) { try { c.close(); } catch (SQLException e) { } } if (ps != null) { try { ps.close(); } catch (SQLException e) { } } } }}public class UserDao { private JdbcContext jdbcContext; public void setJdbcContext(JdbcContext jdbcContext) { this.jdbcContext = jdbcContext; } public void add(Final User user) throws SQLException { this.jdbcContext.workWithStatementStrategy(new StatementStrategy() { @Override public PreparedStrategy makePreparedStrategy(Connection c) throws SQLException { PreparedStatement ps = c.preparedStatement(&quot;insert into users(id, name, password) values(?,?,?)&quot;); ps.setString(1, user.getId()); ps.setString(2, user.getName()); ps.setString(3, user.getPassword()); return ps; } }); }}이제 외부에서 사용할 수 있도록 분리하여 DI를 적용하였다하지만 DI를 적용할 때 인터페이스가 아닌 구체적인 클래스를 적용하였다그렇다면 굳이 DI를 받도록 빈으로 등록할 필요가 있을까?결론부터 말하면 그렇다DI를 위해서는 주입하는 오브젝트와 주입받는 오브젝트 모두 스프링 컨테이너에 등록되어 있어야 하기 때문이다일반적인 DI라면 템플릿에 인스턴스를 만들어 두고 사용할 오브젝트를 주입받아 사용할 것이다하지만 우리가 작성한 코드는 매번 메소드 단위로 사용할 오브젝트를 전달받아 사용한다이러한 패턴을 템플릿/콜백 패턴이라고 한다이제 콜백 메서드를 추출해보자delete와 같이 단일 쿼리로 이루어진 메서드가 사용하도록 메서드를 분리해보자public class UserDao{ public void deleteAll() { executeQuery(&quot;delete from users&quot;); } public void executeQuery(String query) { this.jdbcContext.workWithStatementStrategy(new StatementStrategy() { @Override public PreparedStrategy makePreparedStrategy(Connection c) throws SQLException { PreparedStatement ps = c.preparedStatement(query); return ps; } }); }}이제 deleteAll 메서드가 매우 간단해졌다추출해낸 executeQuery 메서드는 UserDao만 가지고 있기에 아까우니까 JdbcContext로 이동해보자public class JdbcContext { public void executeQuery(String query) { this.jdbcContext.workWithStatementStrategy(new StatementStrategy() { @Override public PreparedStrategy makePreparedStrategy(Connection c) throws SQLException { PreparedStatement ps = c.preparedStatement(query); return ps; } }); }}public class UserDao{ public void deleteAll() { this.jdbcContext.executeQuery(&quot;delete from users&quot;); }}이제 모든 DAO 메서드에서 executeSql 메서드를 사용할 수 있게 되었다템플릿/콜백의 응용고정된 작업 흐름을 가지고 있으면서, 여기저기 반복되는 코드가 있다면, 중복되는 코드를 분리할 방법을 생각해보아야 한다중복된 코드는 먼저 메소드롤 분리하는 간단한 시도를 해 본다그중 필요에 따라 바꾸어야 하는 부분이 있다면, 인터페이스를 사이에 두고 분리해서 전략 패턴을 적용하고 DI로 의존관계를 관리한다만약 바뀌는 부분이 여러 종류가 만들어진다면, 템플릿/콜백 패턴을 적용할 것을 고려할 수 있다이번 포스팅에서 알아본 것을 정리하면 다음과 같다 JDBC와 같이 예외 발생 가능성이 있으며 공유 리소스 반환이 필요한 코드는 반드시 try/catch/finally 블록으로 관리하자 일정한 작업 흐름이 반복되면서, 그중 일부 기능만 바뀌는 코드가 존재한다면 전략 패턴을 적용한다 변하지 않는 부분을 템플릿, 변하는 부분을 전략으로 만들고 인터페이스를 통해 유연하게 전략을 변경한다 같은 어플리케이션 내부에서 여러 종류의 전략을 다이나믹하게 구성하고 사용해야 한다면 컨텍스트를 이용하는 클라이언트 메소드에서 직접 전략을 정의해야 한다 클라이언트 메소드 안에 익명 내부 클래스를 사용하여 전략 오브젝트를 구성하면 편리하다 컨텍스트가 하나 이상의 클라이언트 오브젝트에서 사용된다면 클래스를 분리해서 공유하도록 한다 단일 전략 메소드를 갖는 전략 패턴이면서, 익명 내부 클래스를 사용해서 매번 전략을 다르게 가져가고, 컨텍스트 호출과 동시에 전략 DI를 수행하는 방식을 템플릿/콜백 패턴이라고 한다 콜백의 코드에도 일정한 패턴이 반복된다면, 콜백을 템플릿에 넣고 재활용하도록 한다 템플릿과 콜백의 타입이 바뀔 수 있다면 제너릭스를 사용하도록 한다" }, { "title": "스프링 예외(Exception)", "url": "/posts/spring-exception/", "categories": "Spring, Core", "tags": "spring, exception", "date": "2021-12-01 09:00:01 +0900", "snippet": "잘못된 예외 처리 코드는 찾기 힘든 버그를 낳을 수 있다대표적인 잘못된 예외 처리 코드를 알아보고 예외 처리 전략도 알아보자예외 블랙홀try{ // SQL 쿼리 전송} catch(SQLException e){}예외가 발생하면 그것을 잡아내는 것은 좋은데, 아무것도 아닌 것처럼 넘어가면 문제가 발생한다결국 발생 예외로 인해 어떤 기능이 비정상 동작하거나, 메모리나 리소스가 소진되는 경우가 발생할 것이다비슷한 코드로 다음과 같은 코드들이 있다try{ // SQL 쿼리 전송} catch(SQLException e){ System.out.println(e.getMessage());}발생한 예외를 콘솔에 출력해 주고는 있지만, 이는 그냥 넘어갈 확률이 높기 때문에 동일하다고 볼 수 있다그렇다면 어떻게 처리해야 할까예외를 처리할 때 반드시 지켜야 할 핵심 원칙은 한 가지다모든 예외는 적절하게 복구되던지 작업을 중단하고 관리자에게 분명히 통보되어야 한다무책임한 throwscatch 블록으로 예외를 잡아 봐야 해결할 방법도 없고,수많은 API나 라이브러리가 던지는 예외들을 매번 throws로 처리하기 귀찮아지면 다음과 같은 코드가 탄생한다public class Class1{ public void method1() throws Exception{ method2(); } public void method2() throws Exception{ method3(); } public void method3() throws Exception{}}이러한 메서드를 통해 의미있는 정보를 얻을 수 없다단순히 습관적으로 붙인 것인지, 어떤 예외가 발생할 수 있는 것인지 알 수 없게 되어버린다또한 적절히 처리될 수 있는 예외들도 그냥 넘어가는 문제가 발생할 수 있다예외의 종류와 특징자바에서 throw를 통해 발생시킬 수 있는 예외에는 3가지가 있다Error첫째는 java.lang.Error 클래스의 서브클래스들이다에러는 시스템적 문제가 발생하였을 때 사용된다예를 들면 OutOfMemoryError나 ThreadDeath같은 것이 있다이러한 에러는 처리할 수 있는 것이 없으므로 신경쓰지 않아도 된다Exception과 체크 예외java.lang.Exception 클래스와 그 서브클래스로 정의되는 예외들은개발자들이 어플리케이션 코드의 작업 중 예외상황이 발생했을경우 사용된다Exception 예외는 체크 예외와 언체크 예외로 나뉘는데언체크 예외는 Exception.RuntimeException 클래스를 상속받은 예외를 말하고체크 예외는 상속받지 않은 예외를 말한다체크 예외가 발생할 수 있는 메소드를 사용할 경우 반드시 예외를 처리하는 코드를 함께 작성해야 한다언체크 예외는 런타임 클래스를 상속받기에 런타임 예외라고 불리기도 한다먼저 예외를 처리하는 일반적인 방법을 생각해보고 효과적인 예외처리 전략을 생각해보자예외 복구첫 번째 예외 처리 방법은 예외상황을 파악하고 문제를 해결해서 정상 상태로 돌려놓는 것이다예외처리를 강제하는 체크 예외는 개발자로 하여금 예외상황이 발생할 수 있음을 인식하도록 도와주고,이에 대한 적절한 처리를 시도해보도록 요구하는 것이다예를 들어 DB 서버에 접속하는 코드가 있다고 하면, DB서버 접속에 실패했을 경우 재시도를 해볼 수 있을 것이다예외처리 회피public void add() throws SQLException{ try{ // JDBC API } catch(SQLException e){ // 에러 출력 throw e; }}이처럼 만약 예외 처리가 자신의 역할이 아니라고 생각하면 예외를 밖으로 던져버릴 수 있다이러한 방법은 꼭 분명한 의도를 가지고 있어야 한다던진 예외를 받은 쪽에서도 자신의 역할이 아니라고 생각하면 또 예외를 밖으로 던지게 될 것이다예외처리 전환마지막으로, 예외를 처리하는 방법에 예외 전환이 있다예외를 받아서 적절한 예외로 전환하여 밖으로 던지는데 이는 분명 예외 회피와는 다르다예외 전환은 보통 두 가지 목적으로 사용된다첫째, API에서 발생한 로우레벨의 예외를 상황에 적합한 의미를 가진 예외로 변경하는 것이다예를 들어 동일한 ID를 가진 사용자를 DB에 등록하려고 하면 SQLException을 발생시킬 것이다이 메소드를 그대로 밖으로 던져버리면 서비스 계층에서는 왜 SQLException이 발생했는지 알 수 없을 것이다만약 SQLException을 DuplicateUserIdException같은 예외로 바꾸어 던진다면,서비스 계층에서는 적절한 복구 작업을 시도할 수 있을 것이다public void add() throws SQLException{ try{ // JDBC API } catch(SQLException e){ if (e.getErrorCode() == MysqlErrorNumbers.ER_DUP_ENTRY){ throw DuplicateUserIdException(e); } else{ throw e; } }}보통 전환하는 예외에 원래 발생한 예외를 담아 중첩 예외를 만드는 것이 좋다그래서 SQLException을 생성자의 파라미터로 전달했다다음으로 예외를 처리하기 쉽게 만들기 위해 포장하는 것이다의미를 명확하게 하려고 포장하는 것이 아니라는 점에서 첫번째 방법과는 다르다예를 들면 EJBException을 들 수 있다EJB 컴포넌트에서 발생하는 예외는 대부분 복구 가능한 예외가 아니므로 런타임 예외인 EJBException으로 포장해 던지는 것이다이렇게 처리할 경우 시스템 익셉션으로 파악하고 트랜잭션을 자동으로 롤백해준다예외처리 전략런타임 예외의 일반화 (낙관적 예외 처리)일반적으로 체크 예외는 꼭 처리해야 할 예외, 언체크 예외는 처리할 필요가 없는 예외라고 하였다하지만 스프링 서버 환경에서는 이런 방식을 적용하지 않는 경우가 많다단일 사용자 환경에서 오류가 발생했을 경우, 예를 들어 엑셀 파일과 같은 경우 오류는 반드시 복구되어야 한다하지만 다중 사용자 환경인 서버 환경에서, 작업을 중단하고 복구할 방법은 없다따라서 예외사항을 미리 파악하고 예외가 발생하지 않도록 하거나, 예외가 발생하면 중단하고 관리자가 알도록 해야 할 것이다따라서 위에서 사용한 add 메소드를 런타임 예외로 전환하여 사용할 것이다중복 ID로 인해 발생한 예외는 외부에서 충분히 처리 가능한 예외이므로 이는 그대로 놔둘 것이다public class DuplicateUserIdException extends RuntimeException{ public DuplicateUserIdException(Throwable cause) { super(cause); }}public void add() throws SQLException{ try{ // JDBC API } catch(SQLException e){ if (e.getErrorCode() == MysqlErrorNumbers.ER_DUP_ENTRY){ throw DuplicateUserIdException(e); // 예외 전환 } else{ throw new RuntimeException(e); // 예외 포장 } }}애플리케이션 예외외부의 예외 상황이 아니라 애플리케이션 자체의 로직에 의해 발생하도록 만든 예외를 애플리케이션 예외라고 한다예를 들어 보유한 금액 이상을 출금하는 명령이 들어왔을 때 허용한 범위를 체크한 뒤 적절한 경고를 사용자에게 보내야 할 것이다이러한 경우, 각 상황에 따라 리턴 값을 다르게 줄 수 있다성공할 경우 0, 실패할 경우 -1 등으로 주는 것이다하지만, 이렇게 리턴 값으로 예외상황을 체크할 경우 리턴 값을 체졔적으로 관리하지 않으면 혼란이 올 수 있다그 다음 방법으로, 예외 상황에 대해서는 비즈니스적인 의미를 띈 예외를 던지도록 만드는 것이다잔고 부족의 경우 InsufficientBalanceException을 던지는 것이다try{ BigDecimal balance = account.withdraw(amount);} catch(InsufficientBalanceException e){ BigDecimal availFunds = e.getAvailFunds(); // 잔고 부족 메시지 출력}이번 포스팅에서 알아본 내용들을 정리하면 다음과 같다 예외를 잡아서 아무런 조취를 취하지 않거나 의미없는 throws 선언을 남발하는 것은 위험하다 예외는 복구하거나 적절한 예외로 전환해야 한다 좀더 의미있는 예외로 변경하거나, 불필요한 catch/throws를 피하기 위해 런타임 예외로 포장하자 복구할 수 없는 예외는 런타임 예외로 전환하자 애플리케이션 로직을 담기 위한 예외는 체크 예외로 만든다 SQLException의 에러 코드는 DB에 종속되기 때문에 DB에 독립적인 예외로 전환될 필요가 있다 스프링은 DataAccessException을 통해 DB에 독립적으로 적용 가능한 추상화된 런타임 예외를 제공한다" }, { "title": "스프링 테스트(test)", "url": "/posts/spring-test/", "categories": "Spring, Test", "tags": "spring, test, junit", "date": "2021-11-30 09:00:01 +0900", "snippet": "어떤 기능을 테스트 할 때 고려할 사항이 몇 가지 존재한다하나하나 살펴보자작은 단위의 테스트어떤 기능을 개발할 때 높은 응집도를 가지는 것이 좋다고 했다테스트를 작성할 때에도 동일하게 관심사의 분리가 이루어져야 한다테스트의 관심이 다르다면 테스트할 대상을 분리하고 집중해서 접근해야 한다이렇게 작은 단위의 코드에 대해 테스트를 수행한 것을 단위 테스트(Unit Test)라고 한다여기서 말하는 단위는 정해진 것이 아니며, 하나의 관심에 집중해 효율적으로 테스트 할 수 있는 범위의 단위로 보면 된다자동수행 테스트테스트를 진행할 때 웹 화면에 폼을 띄운 뒤 매번 값을 입력하고 클릭하는 과정을 반복하면 효율성이 저하될 것이다자바 코드로만 작성되어 자동으로 수행되는 테스트의 경우 코드의 수정이 발생해도 빠르게 테스트를 실행할 수 있다지속적 개선과 점진적 개발을 위한 테스트각 기능들에 대해 테스트를 작성하면서 코드를 작성하면 나중에 설계 오류가 발견되는 상황에서도어떤 부분에 문제가 발생했는지 확신을 가지고 찾아낼 수 있게 된다또 기능을 추가하려고 해도 미리 만들어 놓은 테스트 코드는 유용하다새로운 기능을 추가한다고 해도 기존에 만들어뒀던 기능들이 수정한 코드에 영향을 받지 않고 동작하는 것을 확인할 수 있다UserDaoTest의 문제점여기 이전 spring IoC 를 학습하기 위해 작성한 테스트 코드가 있다public class UserDaoTest{ public static void main(String[] args) throws SQLException{ ApplicationConext = new GenericXmlApplicationContext(&quot;applicationContext.xml&quot;); UserDao dao = context.getBean(&quot;userDao&quot;, UserDao.class); User user = new User(); user.setId(&quot;user&quot;); user.setName(&quot;안재홍&quot;); user.setPassword(&quot;developer&quot;); dao.add(user); System.out.println(user.getId() + &quot; 등록 성공&quot;); User user2 = dao.get(user.getId()); System.out.println(user2.getName()); System.out.println(user2.getPassword()); System.out.println(user2.getId() + &quot; 조회 성공&quot;); }}이 테스트 방법은 main 메소드를 사용하였고, Application Context를 생성하여 UserDao 객체를 직접 호출했다하지만 이 코드에는 여러 문제점들이 존재한다수동 확인 작업의 번거로움위 코드에서 입력과 출력 과정은 자동으로 진행되었으나 그 값을 검증하는 것은 개발자의 몫이다실행 작업의 번거로움만약 테스트의 개수가 증가하면, 단순히 main메소드로 확인하기에는 번거로움이 발생한다UserDaoTest 개선UserDaoTest의 두 가지 문제점을 개선해 보자테스트 검증의 자동화첫 번째 문제점인 테스트 결과의 검증 부분을 코드로 만들어 보자public class UserDaoTest{ public static void main(String[] args) throws SQLException{ ApplicationConext = new GenericXmlApplicationContext(&quot;applicationContext.xml&quot;); UserDao dao = context.getBean(&quot;userDao&quot;, UserDao.class); User user = new User(); user.setId(&quot;user&quot;); user.setName(&quot;안재홍&quot;); user.setPassword(&quot;developer&quot;); dao.add(user); System.out.println(user.getId() + &quot; 등록 성공&quot;); User user2 = dao.get(user.getId()); System.out.println(user2.getName()); System.out.println(user2.getPassword()); // System.out.println(user2.getId() + &quot; 조회 성공&quot;); if (!user.getName().equals(user2.getName())) { System.out.println(&quot;테스트 실패 (name)&quot;); } else if (!user.getPassword().equals(user2.getPassword())) { System.out.println(&quot;테스트 실패 (password)&quot;); } else { System.out.println(&quot;조회 테스트 성공&quot;); } }}이제 검증이 완벽히 자동화 되었다테스트를 실행하고 단순히 성공 메시지만 확인하면 될 것이다이제 다음 문제를 해결해 보자main 메소드가 아닌 JUnit 테스팅 프레임워크는 일정한 패턴을 가진 테스트를 만들 수 있고, 많은 테스트를 간단히 실행시킬 수 있으며,테스트 결과를 종합적으로 볼 수 있고, 테스트가 실패한 곳을 빠르게 찾을 수 있다Junit 테스트로 전환기존의 main 메소드는 제어권을 직접 갖는다JUnit은 테스팅을 위한 프레임워크고 프레임워크는 제어 권한을 넘겨받아 주도적으로 애플리케이션 흐름을 제어한다따라서 JUnit을 사용하면 main 메소드도 필요 없고 오브젝트를 만들어 실행할 필요도 없어진다이제 main 메소드를 제거하고 Junit의 메소드로 변경해 보자Junit은 테스트 메소드가 따라야 할 조건을 두 가지 설정해 놓았는데첫 번째는 public으로 선언되어야 하는 것이고, 다른 하나는 @Test라는 어노테이션을 붙여주는 것이다이를 만족하도록 코드를 수정해 보겠다public class UserDaoTest{ @Test public void addAndGet() throws SQLException{ ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserDao dao = context.getBean(&quot;userDao&quot;, UserDao.class); ... }}이제 테스트 코드의 결과를 검증하는 if/else 문을 Junit이 제공하는 방법으로 전환해 보겠다public class UserDaoTest{ @Test public void addAndGet() throws SQLException{ ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserDao dao = context.getBean(&quot;userDao&quot;, UserDao.class); User user = new User(); user.setName(&quot;안재홍&quot;); user.setId(&quot;koji4321&quot;); user.setPassword(&quot;springno1&quot;); dao.add(user); User user2 = dao.get(user.getId()); assertThat(user2.getName(), is(user.getName())); assertThat(user2.getPassword(), is(user.getPassword())); }}이렇게 JUnit을 이용하도록 테스트 코드를 수정하였다하지만 이 코드에도 문제가 있다UserDaoTest의 문제는 이전 테스트 때문에 DB에 등록된 중복 데이터가 있을 수 있다는 점이다가장 좋은 해결책은 addAndGet() 테스트를 마치고 나면 테스트가 등록한 사용자 정보를 삭제하는 것이다User 테이블의 모든 레코드를 삭제하는 deleteAll 메소드를 작성해 보자public class UserDao{ public void deleteAll() throws SQLException { Connection c = dataSource.getConnection(); PreparedStatement ps = c.preparedStatement(&quot;delete from users&quot;); ps.executeUpdate(); ps.close(); c.close(); }}그리고 삭제 확인을 위해 레코드 개수를 확인하는 getCount 메소드를 작성해 보자public class UserDao{ public int getCount() throws SQLException { Connection c = dataSource.getConnection(); PreparedStatement ps = c.preparedStatement(&quot;select count(*) from users&quot;); ResultSet rs = ps.executeQuery(); rs.next(); int count = rs.getInt(1); rs.close(); ps.close(); c.close(); }}이제 테스트 코드에서 작성한 기능들을 사용해보자public class UserDaoTest{ @Test public void addAndGet() throws SQLException{ ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserDao dao = context.getBean(&quot;userDao&quot;, UserDao.class); dao.deleteAll(); assertThat(dao.getCount(), is(0)); User user = new User(); user.setName(&quot;안재홍&quot;); user.setId(&quot;koji4321&quot;); user.setPassword(&quot;springno1&quot;); dao.add(user); assertThat(dao.getCount(), is(1)); User user2 = dao.get(user.getId()); assertThat(user2.getName(), is(user.getName())); assertThat(user2.getPassword(), is(user.getPassword())); }}이제 몇 번을 실행하더라도 동일한 결과를 보장할 수 있게 되었다하지만 만약, get 메서드의 입력값에 존재하지 않는 id값이 입력되면 어떻게 될까추가적으로 get 메서드의 입력값에 대한 예외조건을 처리하기 위해 @Test 어노테이션의 파라미터를 지정해 줄 수 있다테스트 중에 발생할 것으로 기대하는 예외 클래스를 지정하면 정상적으로 동작할 것이다또한 get 메서드에서도 예외가 발생할 것이므로 이를 밖으로 던져 주도록 수정해야 할 것이다public class UserDaoTest{ @Test(expected=EmptyResultDataAccessException.class) public void getUserFailure() throws SQLException{ ApplicationContext context = new GenericXmlApplicationContext(&quot;applicationContext.xml&quot;); UserDao dao = context.getBean(&quot;userDao&quot;, userDao.class); dao.deleteAll(); assertThat(dao.getCount(), is(0)); dao.get(&quot;unknown_id&quot;); // 오류 발생 지점 }}public class UserDao{ public User get() throws SQLException { ... ResultSet rs = ps.executeQuery(); User user = null; if (rs.next()) { user = new User(); user.setName(rs.getString(id)); user.setName(rs.getString(name)); user.setName(rs.getString(password)); } rs.close(); ps.close(); c.close(); if (user == null) { throw new EmptyResultDataAccessException(1); } return user; }}이제 정말 정상적으로 동작되는 코드가 작성되었다이제 JUnit 프레임워크가 제공하는 다양한 기능들을 사용하여 성능을 향상시키고, 단순화를 시켜 보자먼저 UserDaoTest의 코드를 살펴 보면, 중복되는 코드가 존재한다ApplicationContext를 생성하고 UserDao 빈을 받아오는 과정이 중복된다JUnit에는 중복된 과정을 생략할 수 있도록 @Before 어노테이션을 제공한다이를 활용하면 다음과 같이 작성할 수 있다public class UserDaoTest{ private UserDao dao; @Before public void setUp() { ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); dao = context.getBean(&quot;userDao&quot;, UserDao.class); } @Test public void addAndGet() throws SQLException{ User user = new User(); user.setName(&quot;안재홍&quot;); user.setId(&quot;koji4321&quot;); user.setPassword(&quot;springno1&quot;); dao.add(user); User user2 = dao.get(user.getId()); assertThat(user2.getName(), is(user.getName())); assertThat(user2.getPassword(), is(user.getPassword())); }}JUnit이 하나의 테스트 클래스를 가져와 테스트를 수행하는 방식은 다음과 같다 테스트 클래스에서 @Test가 붙은 public이고 void형이며 파라미터가 없는 메서드를 모두 찾는다 테스트 클래스의 오브젝트를 하나 만든다 @Before이 붙은 메서드를 실행한다 @Test가 붙은 메소드를 하나 호출하고 테스트 결과를 저장한다 @After이 붙은 메서드가 있으면 실행한다 나머지 메서드에 대해 2~5를 반복한다 테스트 결과를 종합해 돌려준다테스트 코드에서 필요한 정보나 오브젝트를 픽스쳐(Fixture)라고 한다일반적인 픽스쳐는 여러 테스트에서 반복 사용되므로 @Before 메서드를 이용해 생성해 두면 편하다UserDaoTest 클래스에서 픽스쳐는 UserDao, User가 해당된다이제 해당 픽스쳐를 미리 선언해놓고 @Before 메서드를 통해 초기화를 시켜 보자public class UserDaoTest{ private UserDao dao; private User user1; private User user2; private User user3; @Before public void setUp() { ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); dao = context.getBean(&quot;userDao&quot;, UserDao.class); this.user1 = new User(&quot;koji&quot;, &quot;안재홍&quot;, &quot;spingno1&quot;); this.user2 = new User(&quot;panda&quot;, &quot;오승주&quot;, &quot;kubernetesno1&quot;); this.user3 = new User(&quot;bdj&quot;, &quot;배동준&quot;, &quot;displayno1&quot;); } @Test public void addAndGet() throws SQLException{ dao.add(user1); User findUser = dao.get(user1.getId()); assertThat(findUser.getName(), is(user.getName())); assertThat(findUser.getPassword(), is(user.getPassword())); }}이제 ApplicationContext의 생성 방식을 변경해 보자지금까지는 매 테스트마다 ApplicationContext를 생성했다각 테스트는 독립된 상황에서 독립적인 오브젝트를 사용하는 것이 원칙이나, 생성에 시간과 자원이 많이 소모되는 경우,테스트 전체가 공유하는 오브젝트를 만들기도 한다ApplicationContext는 초기화된 후 변경되는 일이 없고, 각 빈은 싱글톤 방식으로 생성되어 stateless 상태이다따라서 이 ApplicationContext를 여러 테스트에서 공유하도록 작성할 수 있다@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &quot;/applicationContext.xml&quot;)public class UserDaoTest { @Autowired private ApplicationContext context; ... @Before public void setUp() { this.dao = this.context.getBean(&quot;userDao&quot;, UserDao.class); }}@ContextConfiguration 어노테이션에 지정한 설정 파일을 읽어서 초기화하는 과정을 진행했다하지만 우리가 작성한 applicationContext.xml에는 ApplicationContext에 관련된 빈이 존재하지 않는데 어떻게 된 것일까ApplicationContext는 초기화할 때 자기 자신도 빈으로 등록한다따라서 해당 빈이 존재하고 DI도 가능해진 것이다그렇다면 굳이 ApplicationContext를 DI받지 않고, UserDao빈을 DI받으면 되지 않을까?@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &quot;/applicationContext.xml&quot;)public class UserDaoTest { @Autowired private UserDao dao; ... @Before public void setUp() { ... }}이렇게 DI가 완료된 UserDao를 가지게 되었다여기서 @Autowired는 변수에 할당 가능한 타입을 가진 빈을 자동으로 찾는다만약 타입이 여러 개인 경우 CamelCase를 적용하여 동일한 이름을 가진 빈을 주입한다이제 얼추 해결 된 듯 보이지만, 아직 문제가 남아 있다지금까지 사용한 DB가 운영용 DB라고 생각하면, 이를 가지고 테스트를 진행할 수는 없을 것이다따라서 새로운 테스트용 DB를 사용하는 것이 필요한데, 이는 새로운 컨테이너 설정 파일을 사용하는 것으로 해결이 가능하다@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &quot;/test-applicationContext.xml&quot;)public class UserDaoTest { ...}이번 포스팅에서 알아본 것들을 총 정리하면 다음과 같다 테스트는 자동화되어야 하고, 빠르게 실행할 수 있어야 한다 main()테스트 대신 JUnit 프레임워크를 이용한 테스트 작성이 편리하다 테스트 결과는 일관성이 있어야 한다. 코드의 변경 없이 환경이나 실행 순서에 무관하게 실행되어야 한다 테스트는 포괄적으로 작성해야 한다. 충분한 검증을 하지 않는 테스트는 없는 것보다 나쁘다 코드 작성과 테스트 수행 사이의 간격이 짧을수록 효과적이다 테스트하기 쉬운 코드가 좋은 코드다 테스트를 만들고 테스트를 성공시키도록 코드를 작성하는 TDD도 유효한 개발방법이다 테스트 코드 또한 리팩토링이 필요하다 @Before, @After를 사용해서 테스트 메소드들의 공통 준비 작업과 정리 작업을 처리할 수 있다 스프링 테스트 컨텍스트 프레임워크를 사용하면 성능을 향상할 수 있다 동일한 설정파일을 사용하는 테스트는 하나의 ApplicationContext를 공유한다" }, { "title": "스프링 싱글톤(Singleton)", "url": "/posts/spring-singleton/", "categories": "Spring, Core", "tags": "spring, singleton", "date": "2021-11-29 09:00:01 +0900", "snippet": "싱글톤 패턴 (Singleton Pattern)싱글톤 패턴은 어떤 클래스를 애플리케이션 내에서 주로 하나만 존재하도록 강제하는 패턴이다이렇게 만들어진 클래스의 오브젝트는 애플리케이션 내에서 전역적으로 접근이 가능하다단일 오브젝트만 존재해야 하고, 이는 애플리케이션의 여러 곳에서 공유하는 경우에 주로 사용한다서버 어플리케이션과 싱글톤스프링은 기본적으로 싱글톤 방식으로 빈을 생성한다이는 스프링이 주로 적용되는 대상이 자바 엔터프라이즈 기술을 사용하는 서버 환경이기 때문이다일반적인 서버 환경은 초당 수십, 수백번의 요청을 처리해야 하고,매 요청마다 로직을 담당하는 오브젝트를 생성하면, 생성과 가비지 콜렉션에 사용되는 리소스가 증가하고서버가 감당해야 할 부하가 증가한다따라서 이를 해결하기 위해 애플리케이션 안에서 한 개의 오브젝트만 만들어서 사용하도록 한 것이 바로 싱글톤 패턴이다자바 기반 싱글톤 패턴의 한계일반적인 싱글톤 패턴을 구현한 코드는 다음과 같다public class UserDao{ public static USerDao INSTANCE; private UserDao(ConnectionMaker connectionMaker){ this.connectionMaker = connectionMaker; } public static synchronized UserDao getInstance(){ if (INSTANCE == null) { INSTANCE = new UserDao(...); return INSTANCE; } }}이러한 방식을 사용하면 여러 문제가 발생하는데 하나씩 살펴보자private 생성자를 갖기 때문에 상속이 불가능하다싱글톤 패턴은 생성자를 private 으로 제한하여 자기 자신 이외에는 객체를 만들 수 없도록 한다따라서 이 클래스는 상속이 불가능하고 객체지향적인 설계의 장점을 적용하기 어려워진다테스트하기 어렵다싱글톤은 만들어지는 방식이 제한적이기 때문에 테스트에 사용하기 어렵다서버환경에서 싱글톤이 하나만 만들어지는 것을 보장하지 못한다클래스 로더를 구성하는 방법, 여러 JVM에 분산되어 설치되는 방식에 따라 싱글톤을 보장할 수 없다전역 상태를 만들 수 있기 때문에 바람직하지 못하다싱글톤의 static 메소드를 통해 전역 변수처럼 사용할 수 있다전역 변수처럼 사용하는 경우 객체지향적 관점에서 바람직하지 않다싱글톤 레지스트리위와 같은 단점을 해결하기 위해 스프링 컨테이너는 싱글톤 레지스트리 기능을 제공한다싱글톤 레지스트리에 사용될 클래스는 private 생성자를 가질 필요가 없으며, static 메서드를 가질 필요가 없다이를 통해 싱글톤 패턴을 염두에 두지 않고 작성할 수 있고 이는 객체지향적 설계에 매우 적합하다싱글톤 레지스트리 사용의 주의점일반적인 멀티스레드 환경이라면 여러 스레드에서 동시 접근하여 사용할 수 있다만약 읽기 전용이 아닌 값에 동시에 접근하면 의도치 않은 결과를 낳을 수 있다" }, { "title": "예제로 살펴보는 객체지향의 원칙", "url": "/posts/aop/", "categories": "Spring, Core", "tags": "spring, aop", "date": "2021-11-25 09:00:01 +0900", "snippet": "다음과 같은 User 클래스가 있다고 해보자public class User{ String id; String name; String password; public String getId() { return id; } public void setId(String id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getPassword() { return password; } public String setPassword(String password) { this.password = password; }}이제 이 사용자 정보를 DB에 넣고 관리할 수 있는 DAO 클래스를 만들어보자public class UserDao{ public void add(User user) throws ClassNotFoundException, SQLException { Class.forName(&quot;com.mysql.jdbc.Driver&quot;); Connection c = DriverManager.getConnection(&quot;jdbc:mysql://localhost/springbook&quot;, &quot;spring&quot;, &quot;book&quot;); PreparedStatement ps = c.prepareStatement(&quot;insert into users(id, name, password) values(?,?,?)&quot;); ps.setString(1, user.getId()); ps.setString(2, user.getName()); ps.setString(3, user.getPassword()); ps.executeUpdate(); ps.close(); c.close(); } public User get(String id) throws ClassNotFoundException, SQLException{ Class.forName(&quot;com.mysql.jdbc.Driver&quot;); Connection c = DriverManager.getConnection(&quot;jdbc:mysql://localhost/springbook&quot;, &quot;spring&quot;, &quot;book&quot;); PreparedStatement ps = c.prepareStatement(&quot;select * from users where id = ?&quot;); ps.setString(1, id); ResultSet rs = ps.executeQuery(); rs.next(); User user = new USer(); user.setId(rs.getString(&quot;id&quot;)); user.setName(rs.getString(&quot;name&quot;)); user.setPassword(rs.getString(&quot;password&quot;)); rs.close(); ps.close(); c.close(); return user; }}관심사 분리하기개발자는 객체를 설계할 떄 미래의 변화를 고려해야 한다요구사항의 변화가 생기면 코드를 수정해야 할 것이고개발자는 매번 필요한 작업을 최소화해야 하며 변경이 다른 곳에 문제를 일으키지 않게 해야 할 것이다이러한 설계는 바로 분리와 확장을 고려한 설계에서 나온다먼저 관심사의 분리를 고려하도록 코드를 변경해보자위의 UserDao에서 add() 메서드와 get() 메서드는 DB와의 Connection을 가져오는 동일한 코드가 존재한다중복된 DB연결을 getConnection()이라는 이름의 독립적인 메서드로 추출해보자public class UserDao{ public void add(User user) throws ClassNotFoundException, SQLException { Connection c = getConnection(); PreparedStatement ps = c.prepareStatement(&quot;insert into users(id, name, password) values(?,?,?)&quot;); ps.setString(1, user.getId()); ps.setString(2, user.getName()); ps.setString(3, user.getPassword()); ps.executeUpdate(); ps.close(); c.close(); } public User get(String id) throws ClassNotFoundException, SQLException{ Connection c = getConnection(); PreparedStatement ps = c.prepareStatement(&quot;select * from users where id = ?&quot;); ps.setString(1, id); ResultSet rs = ps.executeQuery(); rs.next(); User user = new USer(); user.setId(rs.getString(&quot;id&quot;)); user.setName(rs.getString(&quot;name&quot;)); user.setPassword(rs.getString(&quot;password&quot;)); rs.close(); ps.close(); c.close(); return user; } public Connection getConnection() throws ClassNotFoundException, SQLException{ Class.forName(&quot;com.mysql.jdbc.Driver&quot;); return DriverManager.getConnection(&quot;jdbc:mysql://localhost/springbook&quot;, &quot;spring&quot;, &quot;book&quot;); }}이제 DB 연결과 관련된 부분에 변경이 일어났을 경우, getConnection() 메서드의 코드만 수정하면 된다이제 또다른 상황을 가정해보자getConnection()을 수정해 사용할 일이 많아지고, UserDao 클래스를 수정하지 않도록 해야 한다상속을 통한 확장getConnection() 메서드를 수정하도록 추상 메서드로 변경해서 이를 상속하도록 해 보자public static class UserDao{ public void add(User user) throws ClassNotFoundException, SQLException { Connection c = getConnection(); PreparedStatement ps = c.prepareStatement(&quot;insert into users(id, name, password) values(?,?,?)&quot;); ps.setString(1, user.getId()); ps.setString(2, user.getName()); ps.setString(3, user.getPassword()); ps.executeUpdate(); ps.close(); c.close(); } public User get(String id) throws ClassNotFoundException, SQLException{ Connection c = getConnection(); PreparedStatement ps = c.prepareStatement(&quot;select * from users where id = ?&quot;); ps.setString(1, id); ResultSet rs = ps.executeQuery(); rs.next(); User user = new USer(); user.setId(rs.getString(&quot;id&quot;)); user.setName(rs.getString(&quot;name&quot;)); user.setPassword(rs.getString(&quot;password&quot;)); rs.close(); ps.close(); c.close(); return user; } public static Connection getConnection() throws ClassNotFoundException, SQLException{ // 수정할 코드 }}public class NUserDao extends UserDao { public static Connection getConnection() throws ClassNotFoundException, SQLException{ // N사가 사용할 Connection 구현 }}public class DUserDao extends UserDao { public static Connection getConnection() throws ClassNotFoundException, SQLException{ // D사가 사용할 Connection 구현 }}이제 UserDao 클래스를 수정하지 않고도 상속을 통해 손쉽게 확장이 가능해졌다이렇게 슈퍼클래스에 기본적인 로직의 흐름을 만들고,그 기능의 일부를 추상 메서드나 오버라이딩이 가능한 protected 메서드로 만들어서브클래스에서 이러한 메서드를 필요에 맞게 구현해서 사용하도록 하는 방법을 템플릿 메소드 패턴이라고 한다또한 서브클래스에 Connection 클래스의 생성 방법을 결정하기 때문에 팩토리 메소드 패턴이라고도 할 수 있다이렇게 만들어진 UserDao 클래스에는 또 다른 몇 가지 문제가 존재한다먼저, 상속을 통해 만들어진 클래스와 UserDao 클래스는 긴밀한 결합을 허용한다서브클래스는 슈퍼클래스의 기능을 사용할 수 있고, 만약 슈퍼클래스의 수정이 일어나면 서브클래스에도 영향을 줄 것이다또한, 상속, 구현한 getConnection() 메서드를 다른 클래스에서 사용할 수 없다는 것도 문제이다만약 다른 클래스에서도 동일한 연결을 사용하고 싶다면 중복된 코드를 작성해야 할 것이다클래스의 분리이번엔 관심사가 다르고 변화의 성격이 다른 두 코드를 화끈하게 분리해보자public static class UserDao{ private SimpleConnectionMaker simpleConnectionMaker; public UserDao() { simpleConnectionMaker = new SimpleConnectionMaker(); } public void add(User user) throws ClassNotFoundException, SQLException { Connection c = simpleConnectionMaker.makeNewConnection(); PreparedStatement ps = c.prepareStatement(&quot;insert into users(id, name, password) values(?,?,?)&quot;); ps.setString(1, user.getId()); ps.setString(2, user.getName()); ps.setString(3, user.getPassword()); ps.executeUpdate(); ps.close(); c.close(); } public User get(String id) throws ClassNotFoundException, SQLException{ Connection c = simpleConnectionMaker.makeNewConnection(); PreparedStatement ps = c.prepareStatement(&quot;select * from users where id = ?&quot;); ps.setString(1, id); ResultSet rs = ps.executeQuery(); rs.next(); User user = new USer(); user.setId(rs.getString(&quot;id&quot;)); user.setName(rs.getString(&quot;name&quot;)); user.setPassword(rs.getString(&quot;password&quot;)); rs.close(); ps.close(); c.close(); return user; }}public class SimpleConnectionMaker{ public Connection makeNewConnection() throws ClassNotFoundException, SQLException{ Class.forName(&quot;com.mysql.jdbc.Driver&quot;); return DriverManager.getConnection(&quot;jdbc:mysql://localhost/springbook&quot;, &quot;spring&quot;, &quot;book&quot;); }}이제 위에서 언급했던 문제들이 해결되었다상속이 아닌 새로운 클래스를 사용했기 때문에 결합의 정도가 낮아졌고한 번 작성한 Connection 생성 방법을 다른 클래스에서도 사용할 수 있다하지만 또다른 큰 문제가 발생하였다UserDao 클래스가 SimpleConnectionMaker 클래스에 종속되어 있기 때문에다른 DB Connection을 제공하는 클래스를 제공하기 위해서는 UserDao를 수정해야 한다또한 UserDao 클래스가 SimpleConnectionMaker 클래스의 정보를 너무 많이 알고 있다는 것도 문제이다어떤 클래스가 쓰일지, 그 클래스에서 커넥션을 가져오는 메소드의 이름이 뭔지 알고 있어야 한다인터페이스의 도입두 클래스 간의 긴밀한 연결 관계가 느슨하도록 만들 수 있는 가장 좋은 방법은 추상화가 있다추상화란 어떤 것들의 공통적인 성격을 뽑아내어 이를 따로 분리해내는 작업을 말한다자바에서 추상화를 제공하는 가장 유용한 도구는 바로 인터페이스이다바로 위에서 작성했던 코드에서 SimpleConnectionMaker 클래스를 인터페이스로 수정하면 다음과 같다public static class UserDao{ private SimpleConnectionMaker simpleConnectionMaker; public UserDao() { simpleConnectionMaker = new NConnectionMaker(); } public void add(User user) throws ClassNotFoundException, SQLException { Connection c = simpleConnectionMaker.makeNewConnection(); PreparedStatement ps = c.prepareStatement(&quot;insert into users(id, name, password) values(?,?,?)&quot;); ps.setString(1, user.getId()); ps.setString(2, user.getName()); ps.setString(3, user.getPassword()); ps.executeUpdate(); ps.close(); c.close(); } public User get(String id) throws ClassNotFoundException, SQLException{ Connection c = simpleConnectionMaker.makeNewConnection(); PreparedStatement ps = c.prepareStatement(&quot;select * from users where id = ?&quot;); ps.setString(1, id); ResultSet rs = ps.executeQuery(); rs.next(); User user = new USer(); user.setId(rs.getString(&quot;id&quot;)); user.setName(rs.getString(&quot;name&quot;)); user.setPassword(rs.getString(&quot;password&quot;)); rs.close(); ps.close(); c.close(); return user; }}public interface SimpleConnectionMaker{ public Connection makeNewConnection() throws ClassNotFoundException, SQLException;}public class NConnectionMaker { public Connection makeNewConnection() throws ClassNotFoundException, SQLException{ // N사 구현 Connection 생성 코드 }}public class DConnectionMaker { public Connection makeNewConnection() throws ClassNotFoundException, SQLException{ // D사 구현 Connection 생성 코드 }}이제 모든 문제를 해결한 듯 보인다하지만 아직 하나의 문제가 남아있다생성자에서 어떤 SimpleConnectionMaker 구현체를 사용할 것인지 지정해 주어야 한다는 것이다이는 UserDao 클래스에서 SimpleConnectionMaker 클래스를 생성하는 책임을 가지고 있기 때문에 발생한 것이다따라서 이 책임을 외부로 던져버린다면 다음과 같이 문제를 해결할 수 있을 것이다public static class UserDao{ private SimpleConnectionMaker simpleConnectionMaker; public UserDao(SimpleConnectionMaker simpleConnectionMaker) { this.simpleConnectionMaker = simpleConnectionMaker; } public void add(User user) throws ClassNotFoundException, SQLException { Connection c = simpleConnectionMaker.makeNewConnection(); PreparedStatement ps = c.prepareStatement(&quot;insert into users(id, name, password) values(?,?,?)&quot;); ps.setString(1, user.getId()); ps.setString(2, user.getName()); ps.setString(3, user.getPassword()); ps.executeUpdate(); ps.close(); c.close(); } public User get(String id) throws ClassNotFoundException, SQLException{ Connection c = simpleConnectionMaker.makeNewConnection(); PreparedStatement ps = c.prepareStatement(&quot;select * from users where id = ?&quot;); ps.setString(1, id); ResultSet rs = ps.executeQuery(); rs.next(); User user = new USer(); user.setId(rs.getString(&quot;id&quot;)); user.setName(rs.getString(&quot;name&quot;)); user.setPassword(rs.getString(&quot;password&quot;)); rs.close(); ps.close(); c.close(); return user; }}public interface SimpleConnectionMaker{ public Connection makeNewConnection() throws ClassNotFoundException, SQLException;}public class NConnectionMaker { public Connection makeNewConnection() throws ClassNotFoundException, SQLException{ // N사 구현 Connection 생성 코드 }}public class DConnectionMaker { public Connection makeNewConnection() throws ClassNotFoundException, SQLException{ // D사 구현 Connection 생성 코드 }}이제 생성한 UserDao를 사용하는 클라이언트가 있다고 생각해보자이를 UserDaoTest 클래스라고 하면, 이 클래스에는 Connection의 종류를 결정하여 UserDao 객체를 생성하는 책임이 있다이러한 책임 또한 분리시켜 생각할 필요가 있으므로 DaoFactory 클래스를 만들어 보자public class DaoFactory{ public UserDao userDao() { ConnectionMaker connectionMaker = new DConnectionMaker(); UserDao userDao = new UserDao(connectionMaker); return userDao; }}만약 UserDao가 아닌 AccountDao, MessageDao 등의 클래스가 추가될 경우, 매번 DConnectionMaker 생성 코드를 작성해야 한다따라서 중복을 제거한다면 다음과 같은 코드가 작성된다public class DaoFactory{ public UserDao userDao() { UserDao userDao = new UserDao(connectionMaker()); return userDao; } public UserDao accountDao() { AccountDao accountDao = new AccountDao(connectionMaker()); return userDao; } public MessageDao messageDao() { MessageDao messageDao = new MessageDao(connectionMaker()); return userDao; } public ConnectionMaker connectionMaker() { return new DConnectionMaker(); }}원칙과 패턴개방 폐쇄 원칙 (Open-Closed Principle) 클래스나 모듈은 확장에는 열려 있고 변경에는 닫혀 있어야 한다작성한 UserDao의 경우 DB 연결 방법이라는 기능은 얼마든지 추가가 가능하므로 확장에는 열려 있고자신은 변화에 영향을 받지 않는다는 점에서 변경에는 닫혀 있다고 할 수 있다높은 응집도와 낝은 결합도개방 폐쇄 원칙은 높은 응집도와 낮은 결합도로도 설명 가능하다높은 응집도응집도가 높다는 것은 하나의 모듈, 클래스가 하나의 책임, 또는 관심사에만 집중되어 있다는 뜻이다만약 최초의 UserDao처럼 여러 관심사와 책임이 얽혀 있는 복잡한 코드에서는 변경이 필요한 부분을 찾는 것도 번거롭고변경으로 인해 변경되지 않는 부분에는 다른 영향을 주지 않는지 확인해야 하는 이중의 부담이 생긴다낮은 결합도결합도란 하나의 오브젝트가 변경될 때 관계를 맺고 있는 다른 오브젝트에게 변화를 요구하는 정도를 말한다UserDao에 인터페이스를 도입한 후 DB 연결 기능을 구현한 클래스가 바뀌더라도 DAO의 코드는 변경될 필요가 없게 된다전략 패턴 자신의 context 에서 변경이 필요한 부분을 인터페이스를 통해 외부로 분리시키는 디자인 패턴UserDao는 전략 패턴의 컨텍스트에 해당한다컨텍스트는 자신의 기능 중 변경이 필요한 DB 연결 부분을 SimpleConnectionMaker 인터페이스를 통해 외부로 분리시켰다제어관계 역전 (Inversion of Control, IoC) 제어의 역전이란 제어의 권한을 자신이 아닌 다른 대상에게 위임하는 것예를 들어 최초의 UserDao 클래스는 자신이 직접 어떤 Connection을 만들 것인지 선택하고 생성했다하지만 getConnection() 메서드를 추출함으로써 Connection을 선택하고 생성하는 제어권을 위임하였다이제 정말 깔끔한 코드로 리팩토링을 완료하였다다음은 스프링을 사용하여 좀더 일반적인 IoC를 구현해볼 것이다" }, { "title": "NoSQL과 Redis", "url": "/posts/redis-attribute/", "categories": "Redis", "tags": "nosql, redis", "date": "2021-11-09 09:00:01 +0900", "snippet": "#NoSQL과 Redis##NoSQL 개념데이터 저장 방식은 File System, RDBMS를 거쳐 현재의 NoSQL이 등장하였다NoSQL은 기존의 시스템과 비교하면 많은 장점이 존재하는데, 이를 알아보자###1) 클라우드 컴퓨팅 환경에 적합하다최근 클라우드 컴퓨팅 환경이 적극적으로 도입되고 있다개발 운영 플랫폼은 새로운 변화를 요구하고 있지만여전히 RDBMS로 구축 운영하다 보니 비용 및 성능 문제와 같은 다양한 문제점을 마주하게 된다기존의 DBMS는 대부분 상용 라이센스이다 보니 구축부터 구매 비용이 발생하는데클라우드 컴퓨팅 환경에서는 여러 대의 서버가 필요하다 보니 2~3배 이상의 비용이 발생하게 된다###2) 유연한 데이터 모델이다기존의 RDBMS의 경우 데이터베이스를 분석, 설계, 구축하는 과정에서개념 데이터 모델링, 논리 데이터 모델링, 물리 데이터 모델링 단계를 거쳐 정규화, 반정규화를 수행한 다음,최종 테이블, 인덱스 구조를 생성한다이와 같은 작업은 절대 쉬운 일이 아니며 장기간동안 많은 비용이 발행한다NoSQL의 경우 이와 반대되는 개념으로 비정형 구조라고 불리며 보다 쉽고 간단하게 설계할 수 있다###3) 빅데이터 처리에 효과적이다NoSQL은 빅데이터가 발생하는 비즈니스 환경에서 빠른 성능이 보장될 수 있도록 설계되어 개발된 SW이다일반적으로 잘 설계된 NoSQL DB는 관계형 DB에 비해 최소 3배 이상의 성능을 기대해 볼 수 있다##KeyValue DB 활용###장점1) Redis는 In-Memory 기반의 데이터 저장 구조이다기존 RDBMS의 경우 메모리 -&amp;gt; 디스크 순서로 저장되며 DBMS에 의해 할당되고 관리된다반면 In-Memory DB의 경우 메모리에 저장되며 선택적으로 디스크에 저장된다.또한 이는 DBMS에 의해 할당되거나 관리되지 않으며 예기치 못한 장애가 발생할 경우 모든 데이터는 유실된다2) Key-Value 데이터 구조는 하나의 Key와 데이터 값으로 구성된다RDBMS에서 데이터의 빠른 검색을 위해 인덱스를 사용하는 것처럼 Redis DB에서도 인덱스를 생성할 수 있지만,인덱스의 종류와 구조가 다르기 때문에 표현의 한계가 있다따라서 관계형 DB의 데이터 구조를 그대로 매핑해서 사용할 수는 없으며 데이터의 일부를 잠시 보관할수는 있다3) 가공처리가 요구되는 비즈니스 환경에서 적합하다Redis를 운영하는 사용자 환경을 살펴보면 대부분 Main DB로 RDB를, 보조 DB로 Redis를 사용한다그 이유는 대부분 메인 DB로 선택한 제품들은 파일 기반의 저장 구조이다 보니 디스크 IO 문제로 발생하는 성능 지연 문제를 해소하기 위해키-밸류 DB를 보조 DB로 사용하는 것이다활용 영역1) 실시간 분석 영역메인 DB에는 현재 시점 및 과거 시점 데이터를 저장하고, 필요에 따라 데이터를 읽은 다음가공처리 및 분석 작업은 Redis 서버에서 수행한 후 메모리에 저장하고 그 결과를 사용자에게 제공한다2) IOT 영역인-메모리 기반의 Redis는 매우 경량 DB이므로 IOT 제품들의 데이터를 저장 및 관리하기에 적합하다3) 계측 정보수집 영역계측 장비로부터 수집된 데이터를 쉽고 빠르게 저장, 가공 처리할 수 있다4) 개인화 정보관리 영역Redis DB에 저장되어 있는 데이터를 사용자의 필요에 의해 쉽게 가공 처리하여 편집이 요구되는 비즈니스 환경에 활용할 수 있다5) 전자 상거래 비즈니스 영역기존의 관계형 DBMS를 기반으로 했던 비즈니스 영역에도 동일하게 적용할 수 있다하지만 과거 데이터를 지속적으로 저장, 관리하는 것은 한계가 있으므로 분산-복제 시스템을 구축 운영해야 한다" }, { "title": "Spring Security (2) - 인증(Authentication)", "url": "/posts/spring-security-2/", "categories": "Spring, Security", "tags": "spring security, authentication", "date": "2021-10-01 09:00:01 +0900", "snippet": "#Spring Security 주요 아키텍쳐 이해spring security의 주요 아키텍쳐는 다음과 같다우리는 각 필터들이 어떤 역할을 하는 것인지 알아보고 이를 직접 구현해볼 것이다#SecurityContextPersistenceFilter SecurityContext객체의 생성, 저장, 조회를 담당한다 사용자 인증을 받기 전 SecurityContextRepository로부터 새로운 SecurityContext를 받아 SecurityContextHolder에 저장한다 chain.doFilter()를 통해 최종 인증 객체 Authentication을 받아 SecurityContext에 저장한다 SecurityContext를 Session에 저장한다 SecurityContextHolder.clearContext()를 통해 SecurityContextHolder를 비운다 사용자 인증을 받은 후 Session에서 SecurityContext를 꺼낸다 chain.doFilter()를 진행한다 #UsernamePasswordAuthenticationFilter 사용자의 인증 이후 인증 정보를 Authentication객체에 저장한다###AuthenticationManager 인증 처리 요건에 맞는 AuthenticationProvider를 찾아 인증처리를 위임한다###AuthenticationProvider 자신의 인증처리 방식에 따라 인증 후 사용자 객체, 사용자 권한정보를 Authentication객체에 담아 return한다#Custom Authentication Flow 구현하기이제 DB와 연동하여 인증 기능을 구현해볼 것이다제일 먼저 ID를 가져오는 UserDetailsService를 구현해보자###UserDetailsServiceUserDetailsService인터페이스를 구현한 CustomUserDetailsService 클래스를 작성했다다음은 해당 인터페이스의 loadUserByUsername()클래스를 구현한 것이다public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { Account account = userRepository.findByUsername(username); if (account == null) { if (userRepository.countByUsername(username) == 0) { throw new UsernameNotFoundException(&quot;No user found with username: &quot; + username); } } Set&amp;lt;String&amp;gt; userRoles = account.getUserRoles() .stream() .map(userRole -&amp;gt; userRole.getRoleName()) .collect(Collectors.toSet()); return new UserDetail(account, userRoles.stream().collect(Collectors.toList()));}이제 가져온 UserDetails 객체를 입력한 password와 비교하는 PasswordEncoder를 작성해보자###PasswordEncoderPasswordEncoder객체는 PasswordEncoderFactory를 통해 생성할 수 있다@Beanpublic PasswordEncoder passwordEncoder() { return PasswordEncoderFactories.createDelegatingPasswordEncoder();}createDelegatingPasswordEncoder()메서드는 bcrypt방식을 default로 사용하는 PasswordEncoder를 return한다물론 다른 방식으로도 인코딩을 진행할 수 있도록 작성해놓았다public class PasswordEncoderFactories { public static PasswordEncoder createDelegatingPasswordEncoder() { String encodingId = &quot;bcrypt&quot;; Map&amp;lt;String, PasswordEncoder&amp;gt; encoders = new HashMap(); encoders.put(encodingId, new BCryptPasswordEncoder()); encoders.put(&quot;ldap&quot;, new LdapShaPasswordEncoder()); encoders.put(&quot;MD4&quot;, new Md4PasswordEncoder()); encoders.put(&quot;MD5&quot;, new MessageDigestPasswordEncoder(&quot;MD5&quot;)); encoders.put(&quot;noop&quot;, NoOpPasswordEncoder.getInstance()); encoders.put(&quot;pbkdf2&quot;, new Pbkdf2PasswordEncoder()); encoders.put(&quot;scrypt&quot;, new SCryptPasswordEncoder()); encoders.put(&quot;SHA-1&quot;, new MessageDigestPasswordEncoder(&quot;SHA-1&quot;)); encoders.put(&quot;SHA-256&quot;, new MessageDigestPasswordEncoder(&quot;SHA-256&quot;)); encoders.put(&quot;sha256&quot;, new StandardPasswordEncoder()); encoders.put(&quot;argon2&quot;, new Argon2PasswordEncoder()); return new DelegatingPasswordEncoder(encodingId, encoders); } private PasswordEncoderFactories() { }}###최종 AuthenticationProvider위에서 작성한 인증 클래스들을 조합하여 최종 AuthenticationProvider를 작성해보자다음은 AuthenticationProvider의 authenticate 메서드를 구현한 것이다@Override@Transactionalpublic Authentication authenticate(Authentication auth) throws AuthenticationException { String loginId = auth.getName(); String passwd = (String) auth.getCredentials(); UserDetails userDetails = null; try { // 사용자 조회 userDetails = userDetailsService.loadUserByUsername(loginId); if (userDetails == null || !passwordEncoder.matches(passwd, userDetails.getPassword())) { throw new BadCredentialsException(&quot;Invalid password&quot;); } if (!userDetails.isEnabled()) { throw new BadCredentialsException(&quot;not user confirm&quot;); } } catch(UsernameNotFoundException e) { log.info(e.toString()); throw new UsernameNotFoundException(e.getMessage()); } catch(BadCredentialsException e) { log.info(e.toString()); throw new BadCredentialsException(e.getMessage()); } catch(Exception e) { log.info(e.toString()); throw new RuntimeException(e.getMessage()); } return new UsernamePasswordAuthenticationToken(((UserDetail)userDetails).getAccount(), null, userDetails.getAuthorities());}최종적으로 Authentication 객체를 return해야 하는데우리는 UsernamePasswordAuthenticationFilter를 사용하므로 UsernamePasswordAuthenticationToken 구현체를 return한다첫번째 인자로 Object타입 user객체를 받고, 세번째 인자는 Collection&amp;lt;? extends GrantedAuthority&amp;gt;타입 권한 객체를 받는다.세번째 인자는 Object타입 credentials인데 이는 보안 이슈로 인해 null 처리하는것이 좋다고 한다###Custom Authentication Manager 적용하기만든 Authentication Manager를 적용하려면 @configuration설정 파일에 해당 클래스를 등록해야 한다@Overrideprotected void configure(AuthenticationManagerBuilder auth) { auth.authenticationProvider(authenticationProvider());}이제 서버를 기동하면 우리가 작성한 인증 프로세스가 동작한다Spring Security는 이러한 기본 기능들 이외에 추가적인 기능들을 제공하는데 이번엔 그 기능들을 알아보자###WebAuthenticationDetails, WebAuthenticationDetailsSource 인증 파라미터(id, password)들을 제외한 다른 파라미터, 요청 IP, Session Id 등의 정보를 제공한다이 기능을 사용하려면 WebAuthenticationDetails 객체가 필요한데 이 클래스는 WebAuthenticationDetailsdSource 클래스가 생성한다이제 각 클래스들을 작성해보자다음은 “code” 파라미터를 받아 추가적으로 비교하는 로직을 작성한 것이다public class FormWebAuthenticationDetails extends WebAuthenticationDetails { private static final long serialVersionUID = 1L; private final String verificationCode; public FormWebAuthenticationDetails(HttpServletRequest request) { super(request); verificationCode = request.getParameter(&quot;code&quot;); } public String getVerificationCode() { return verificationCode; }}@Componentpublic class FormWebAuthenticationDetailsSource implements AuthenticationDetailsSource&amp;lt;HttpServletRequest, WebAuthenticationDetails&amp;gt; { @Override public WebAuthenticationDetails buildDetails(HttpServletRequest request) { return new FormWebAuthenticationDetails(request); }}작성한 클래스들을 적용하려면 @Configure클래스의 configure(HttpSecurity httpSecurity)메서드에 정의해주면 된다@Overrideprotected void configure(HttpSecurity httpSecurity){ httpSecurity .(...) .authenticationDetailsSource(authenticationDetailsSource) .(...)}###CustomAuthenticationSuccessHandler, CustomAuthenticationFailureHandler 인증 성공, 실패시 동작할 로직들을 정의한다위 기능들도 주어진 클래스들을 오버라이드하여 사용할 수 있다@Overridepublic void configure(HttpSecurity http) throws Exception { http.formLogin().successHandler(CustomAuthenticationSuccessHandler())}@Overridepublic void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException { RequestCache requestCache = new HttpSessionRequestCache(); // 요청 캐시와 관련된 작업 final HttpSession session = request.getSession(false); // 세션 관련 작업 Object principal = authentication.getPrincipal() // 인증된 사용자 관련작업 redirectStrategy.sendRedirect(request, response, targetUrl); // 인증 성공 후 이동 } }@Overridepublic void configure(HttpSecurity http) throws Exception { http.formLogin().failureHandler(CustomAuthenticationFailureHandler())}@Overridepublic void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException { if (exception instanceof UsernameNotFoundException) { errorMessage = messages.getMessage(“사용자가 존재하지 않습니다.＂, null, locale); } else if (exception instanceof BadCredentialsException) { errorMessage = messages.getMessage(＂아이디 혹은 비밀번호가 일치하지 않습니다.&quot;, null, locale); } else { errorMessage = &quot;인증에 실패했습니다. 웹 마스터에게 문의하십시오.！&quot;; } }###AccessDeniedHandler 인증 후 인가되지 않은 자원에 접근할 때 처리할 로직을 정의한다@Overridepublic void configure(HttpSecurity http) throws Exception { http.exceptionHandling().accessDeniedPage(“/accessDenied&quot;) .accessDeniedHandler(accessDeniedHandler)}@Overridepublic void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException { String deniedUrl = errorPage + &quot;?exception=&quot; + accessDeniedException.getMessage(); response.sendRedirect(request, response, deniedUrl);}public void setErrorPage(String errorPage) { this.errorPage = errorPage;}" }, { "title": "Spring Security 3", "url": "/posts/spring-security-3/", "categories": "", "tags": "", "date": "2021-10-01 00:00:00 +0900", "snippet": "N—title: Spring Security (3) - 인가(Authorization)date: 2021-10-02 00:00:01categories: [Spring, Security]tags: [spring security, authorization] # TAG names should always be lowercase—저번 포스팅에 Spring Security 인증(Authentication) 프로세스를 알아보고 직접 구현해보았다이번에는 인가(Authorization) 프로세스를 알아보자#Spring Security 인가 프로세스##FilterSecurityInteceptor인가를 담당하는 필터는 필터 체인의 가장 마지막에 있는 FilterSecurityInterceptor이다이 필터는 실제 인가 처리를 하지 않으며 단순히 컨트롤러의 역할만 한다이 FilterSecurityInteceptor는 인증 정보, 요청 정보, 권한 정보를 담아 AccessDecisionManager에게 전달한다Custom FilterSecurityInterceptor 필터를 작성하려면 총 3가지 멤버에 주입해야 하는데이것은 각각 SecurityMetadataSource, AccessDecisionManager, AuthenticationManager이다@Beanpublic FilterSecurityInterceptor CustomFilterSecurityInterceptor() throws Exception{ FilterSecurityInterceptor filterSecurityInterceptor = new FilterSecurityInterceptor(); filterSecurityInterceptor.setSecurityMetadataSource(urlFilterInvocationSecurityMetadataSource); filterSecurityInterceptor.setAccessDecisionManager(affirmativeBased()); filterSecurityInterceptor.setAuthenticationManager(authenticationManagerBean()); }##FilterInvocationSecurityMetadataSource (자원, 인가권한) 정보를 가지고 있는 requestMap을 검사하여 요청정보와 매칭되는 권한정보를 FilterSecurityInterceptor에게 전달한다requestMap에 저장된 권한정보들은 직접 작성할 수 있지만 최종적으로는 DB에서 가져오는 것이 목적이다다음은 DB로부터 자원/권한 정보를 얻어와 Bean으로 등록하는 FactoryBean을 작성한 것이다public class UrlResourcesMapFactoryBean implements FactoryBean&amp;lt;LinkedHashMap&amp;lt;RequestMatcher, List&amp;lt;ConfigAttribute&amp;gt;&amp;gt;&amp;gt; { private SecurityResourceService securityResourceService; public void setSecurityResourceService(SecurityResourceService securityResourceService) { this.securityResourceService = securityResourceService; } private LinkedHashMap&amp;lt;RequestMatcher, List&amp;lt;ConfigAttribute&amp;gt;&amp;gt; resourcesMap; public void init() { resourcesMap = securityResourceService.getResourceList(); } public LinkedHashMap&amp;lt;RequestMatcher, List&amp;lt;ConfigAttribute&amp;gt;&amp;gt; getObject() { if (resourcesMap == null) { init(); } return resourcesMap; } public Class&amp;lt;LinkedHashMap&amp;gt; getObjectType() { return LinkedHashMap.class; } public boolean isSingleton() { return true; }}@Servicepublic class SecurityResourceSerivce{ private ResourceRepository resourceRepository; public LinkedHashMap&amp;lt;RequestMatcher, List&amp;lt;ConfigAttribute&amp;gt;&amp;gt; getResourceList() { LinkedHashMap&amp;lt;RequestMatcher, List&amp;lt;ConfigAttribute&amp;gt;&amp;gt; result = new LinkedHashMap&amp;lt;&amp;gt;(); List&amp;lt;Resources&amp;gt; resourcesList = resourcesRepository.findAllResources(); resourcesList.forEach(re -&amp;gt; { List&amp;lt;ConfigAttribute&amp;gt; configAttributeList = new ArrayList&amp;lt;&amp;gt;(); re.getRoleSet().forEach(ro -&amp;gt; { configAttributeList.add(new SecurityConfig(ro.getRoleName())); result.put(new AntPathRequestMatcher(re.getResourceName()), configAttributeList); }); } ); log.debug(&quot;cache test&quot;); return result; } }##인가처리 실시간 반영하기관리자가 인가처리 정책을 바꾼 경우 실시간으로 정책을 수정해주어야 할 것이다이는 작성한 UrlFilterInvocationSecurityMetadataSource에 다음 메서드만 추가함으로서 해결할 수 있다public void reload(){ LinkedHashMap&amp;lt;RequestMatcher, List&amp;lt;ConfigAttribute&amp;gt;&amp;gt; reloadedMap = securityResourceService.getResourceList(); Iterator&amp;lt;Map.Entry&amp;lt;RequestMatcher, List&amp;lt;ConfigAttribute&amp;gt;&amp;gt;&amp;gt; iterator = reloadedMap.entrySet().iterator(); requestMap.clear(); while(iterator.hasNext){ Map.Entry&amp;lt;RequestMatcher, List&amp;lt;ConfigAttribute&amp;gt;&amp;gt; entry = iterator.next(); requestMap.put(entry.getKey(), entry.getValue()); }}##PermitAllFilter 구현하기인증 및 권한심사를 할 필요가 없는 자원들(“/”, “/login”, … )을 미리 설정해 바로 접근이 가능하도록 하는 필터를 구현해보자부모의 beforeInvocation()메서드를 호출하기 전, 미리 검사를 실행하는 코드를 작성하면 된다public PermitAllFilter(String... permitAllPattern) { createPermitAllPattern(permitAllPattern);}@Overrideprotected InterceptorStatusToken beforeInvocation(Object object) { boolean permitAll = false; HttpServletRequest request = ((FilterInvocation) object).getRequest(); for (RequestMatcher requestMatcher : permitAllRequestMatcher) { if (requestMatcher.matches(request)) { permitAll = true; break; } } if (permitAll) { return null; } return super.beforeInvocation(object);}##계층 권한 상위 계층 권한은 하위 계층 권한을 가지고 있어야 한다하지만 지금까지 작성한 코드는 이 계층 권한이 적용되지 않고 있는데 이를 수정해보자" }, { "title": "Spring Security (1)", "url": "/posts/spring-security-1/", "categories": "Spring, Security", "tags": "spring security", "date": "2021-09-28 09:00:01 +0900", "snippet": "# Spring Security란?필자는 이전에 필터를 사용해 로그인 처리를 직접 구현한 경험이 있다.그리 복잡하지 않았던 프로젝트임에도 불구하고 페이지가 추가될때마다 추가적인 설정을 해주는 것이 매우 불편했다실제 서비스에서 이렇게 귀찮은 일을 할리가 없다고 생각하여 이러한 기능을 구현한 라이브러리가 있는지 찾아보았다아니나다를까 Spring 프로젝트의 하위 프로젝트로 Spring Security라는 것이 있었다그렇다면 Spring Security란 어떤 프로젝트일까?위키에 정의된 Spring Security는 다음과 같다 Spring Security는 엔터프라이즈 애플리케이션에 대한 인증, 권한 부여 및 기타 보안 기능을 제공하는 Java / Java EE 프레임 워크입니다.정리를 해보자면 다음 3가지 기능을 제공한다는 것이다 인증 (Authentication) 인가 (Authorization) 기타 보안 기능 (ex. OAuth 2.0)그렇다면 Spring Security는 어떤 방식으로 이를 구현했을까?Spring Security는 기본적으로 필터를 통해 이를 구현한다스프링 필터에 대한 내용은 이전 포스팅을 참고하자이제 Spring Container의 최초 설정부터 사용 예시까지 천천히 따라가면서 알아보자Spring Security 설정하기Spring Security를 사용하기 위해 의존성 추가를 해주자Maven의 경우 다음 dependency를 설정하면 된다&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-security&amp;lt;/artifactId&amp;gt;&amp;lt;/dependency&amp;gt;의존성 추가를 진행해주면 서버가 기동되면서 초기화 작업 및 보안 설정이 이루어진다아무런 설정을 해주지 않으면 기본적인 웹 보안 기능이 시스템에 연동되어 작동한다주소롤 접속하면 다음과 같은 인증 페이지가 제공된다로그인에 제공되는 기본 계정이 하나 있는데 인증 정보는 다음과 같다username: userpassword: 랜덤 문자열(콘솔에 출력됨)위 정보를 입력하면 인증이 완료되고 원하는 자료(/)에 접근할 수 있다하지만 우리는 계정 추가, 권한 추가, DB 연동 등을 추가적으로 설정하고 싶다 이제 설정을 추가해보자설정 파일 적용하기먼저 @Configuration, @EnableWebSecurity 어노테이션을 적용한 Config 클래스를 하나 만들자설정을 추가하려면 WebSecurityConfigurerAdapter 클래스의 configure(HttpSecurity http) 메서드를 오버라이드해야 한다그리고 API 설정을 통해 원하는 설정을 적용할 수 있는데 일단 기본적인 설정을 먼저 살펴보자@Configuration@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http .authorizeRequests() .anyRequest().authenticated() .and() .formLogin(); }} authorizeRequest() : 처리에 Http를 사용한다는 것을 의미(HttpServletRequest) anyRequest().authenticated() : 모든 요청에 대해 인증을 받도록 하는 설정 formLogin() : form 방식으로 로그인 요청을 하겠다는 의미인증 성공, 인증 실패시 로직 추가하기추가적인 API 설정을 통해 인증 성공, 인증 실패시 로직을 추가할 수 있다@Overrideprotected void configure(HttpSecurity http) throws Exception { http .authorizeRequests() .anyRequest().authenticated() .and() .formLogin() .loginPage(&quot;/loginPage&quot;) .defaultSuccessUrl(&quot;/&quot;) .failureUrl(&quot;/login&quot;) .usernameParameter(&quot;userId&quot;) .passwordParameter(&quot;passwd&quot;) .loginProcessingUrl(&quot;/login_proc&quot;) .successHandler(new AuthenticationSuccessHandler() { @Override public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication auth) throws IOException, ServletException { System.out.println(&quot;request success = &quot; + request.getRequestURI()); response.sendRedirect(&quot;/&quot;); } }) .failureHandler(new AuthenticationFailureHandler() { @Override public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException e) throws IOException, ServletException { System.out.println(&quot;e = &quot; + e.getMessage()); response.sendRedirect(&quot;/login&quot;); } }) .permitAll() ;} loginPage(“/login”) : 로그인을 요청할 페이지를 설정 defaultSuccessUrl(“home”) : 로그인 성공 후 이동할 페이지를 설정 failureUrl(“/login?error=true”) : 로그인 실패 후 이동할 페이지를 설정 usernameParameter(“userId”) : 로그인 폼의 username Input 태그의 name값 passwordParameter(“passwd”) : 로그인 폼의 password Input 태그의 name값 loginProcessingUrl(“/login”) : 로그인 폼의 action값 successHandler(loginSuccessHandler()) : 로그인 성공 후 핸들러 failureHandler(loginFailureHandler()) : 로그인 실패 후 핸들러Spring Security 주요 아키텍쳐 이해가장 간단한 설정 클래스를 만들어 사용해 보았다서버가 기동되면 위 설정 클래스를 어떻게 적용하는지 알아보자###FilterChainProxy 서버가 기동되면 @Configure 설정 파일들을 읽는데 우리가 작성된 설정클래스들도 읽힌다 WebSecurityConfigurerAdapter는 우리가 작성한 configure메서드를 읽어 보안 API를 설정하고 필터를 생성한다 기본적으로 적용될 필터들과 생성된 필터들을 엮어 SecurityFilterChain을 만들어 return한다 각 설정파일로부터 만들어진 SecurityFilterChain들은 FilterChainProxy의 리스트 형식으로SecurityFilterChains에 저장된다###DelegatingFilterProxy설정을 완료하고 서버를 기동하면 DelegatingFilterProxy라는 서블릿 필터가 추가된다우리가 작성한 @Configure클래스는 스프링 컨테이너에 등록된 스프링 빈인데 서블릿 필터는 스프링 빈을 사용할 수 없다따라서 특정한 이름을 가진 스프링 빈에게 요청을 위임하게 되는데 이것이 바로 FilterChainProxy이다이제 FilterChainProxy생성을 완료했다사실 이 FilterChainProxy는 Spring Container 내부에 존재하는 스프링 빈이다실제 Security 기능의 시작은 DelegatingFilterProxy 서블릿 필터이다생성된 FilterChainProxy와 DelegatingFilterProxy는 “springSecurityFilterChain”이라는 이름으로 초기화되고이 이름으로 서블릿 필터와 스프링 빈이 연결된다이제 모든 초기화 과정이 완료되었다다음 포스팅에서는 상황별로 세부적인 필터들의 동작에 대해 작성해 보겠다" }, { "title": "Spring 서블릿 필터(Filter)와 스프링 인터셉터(Interceptor)", "url": "/posts/spring-filter/", "categories": "Spring, Web", "tags": "spring, filter, interceptor", "date": "2021-09-28 09:00:01 +0900", "snippet": "서블릿 필터? 스프링 인터셉터?웹 어플리케이션을 개발하다 보면 로그인 처리와 같이 대부분의 로직에서 공통으로 적용해야 할 기능들이 존재한다이렇게 애플리케이션 로직에서 공통으로 관심이 있는 것을 공통 관심사(cross-cutting concern)라고 한다이러한 공통 관심사는 Spring의 AOP를 통해 구현이 가능하지만,로직의 복잡성이 증가할 뿐만 아니라 향후 이와 관련된 로직이 변경되면 작성한 모든 로직을 수정해야 할 것이다따라서 웹과 관련된 공통 관심사는 지금부터 알아볼 서블릿 필터나 스프링 인터셉터를 사용하는 것이 좋다 웹과 관련된 공통 관심사를 처리할 때는 HTTP의 헤더나 URL의 정보들이 필요한데, 서블릿 필터나 스프링 인터셉터는 HttpServletRequest를 제공한다서블릿 필터 소개서블릿 필터는 서블릿이 지원하는 수문장이다필터의 특성은 다음과 같다####필터 흐름HTTP 요청 -&amp;gt; WAS -&amp;gt; 필터 -&amp;gt; 서블릿 -&amp;gt; 컨트롤러필터를 적용하면 필터가 호출 된 다음 서블릿이 호출된다그래서 모든 고객의 요청 로그를 남기는 요구사항이 있다면 필터를 사용하면 된다필터 제한HTTP 요청 -&amp;gt; WAS -&amp;gt; 필터 -&amp;gt; 서블릿 -&amp;gt; 컨트롤러 // 인가 사용자 (로그인 Success)HTTP 요청 -&amp;gt; WAS -&amp;gt; 필터 -&amp;gt; X // 비인가 사용자 (로그인 Fail)필터 체인필터는 체인으로 구성되는데, 중간에 필터를 자유롭게 추가할 수 있다예를 들어 로그를 남기는 필터를 먼저 적용하고, 그 다음에 로그인 여부를 체크하는 필터를 만들 수 있다HTTP 요청 -&amp;gt; WAS -&amp;gt; 필터1 -&amp;gt; 필터2 -&amp;gt; 필터3 -&amp;gt; 서블릿 -&amp;gt; 컨트롤러 // 필터 체인필터 인터페이스필터 인터페이스를 구현하고 등록하면, 서블릿 컨체이너가 필터를 싱글톤 객체로 생성하고, 관리한다public interface Filter{ public default void init() throws ServletException {} public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException; public default void destroy() {}} init() : 필터 초기화 메서드 doFilter(): 고객의 요청이 올 때마다 해당 메서드가 호출된다 destroy() : 필터 종료 메서드, 서블릿 컨테이너가 종료될 때 호출된다필터의 사용서비스 접근 로그를 남기는 필터를 작성하고 적용해 보겠다먼저 로그 필터를 작성해 보자@Slf4jpublic class LogFilter implements Filter{ public void init() throws ServletException { System.out.println(&quot;Filter Initialize&quot;); } public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException{ HttpServletRequest httpRequest = (HttpServletRequest)request; HttpServletResponse httpResponse = (HttpServletResponse)response; String randomUUID = UUID.randomUUID().toString(); try{ log.info(&quot;Request [{}][{}]&quot;, httpRequest.getRequestURI, randomUUID); chain.doFilter(request, response); } catch(Exception e){ throw e; } finally{ log.info(&quot;Response [{}][{}]&quot;, httpResponse.getResponseURI, randomUUID); } } public void destroy() { System.out.println(&quot;Filter Destroy&quot;); }}이제 작성한 필터를 등록해 보자우리는 Spring Boot를 사용하기 때문에 FilterRegistrationBean을 생성해 사용하면 된다@Configurationpublic class WebConfig{ @Bean public FilterRegistrationBean logFilter(){ FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean&amp;lt;&amp;gt;(); filterRegistrationBean.setFilter(new Logfilter()); filterRegistrationBean.setOrder(1); filterRegistrationBean.addUrlPatterns(&quot;/*&quot;); return filterRegistrationBean; }}이제 프로그램을 실행하고 이 서비스로 요청을 보내면 console에 Request, Response 로그가 출력될 것이다스프링 인터셉터 소개스프링 인터셉터도 서블릿 필터와 같이 웹과 관련된 공통 관심 사항을 효과적으로 해결할 수 있는 기술이다 서블릿 필터가 서블릿의 하위 기술이라면 스프링 인터셉터는 스프링 MVC가 제공하는 기술이다####스프링 인터셉터 흐름HTTP 요청 -&amp;gt; WAS -&amp;gt; 필터 -&amp;gt; 서블릿 -&amp;gt; 스프링 인터셉터 -&amp;gt; 컨트롤러스프링 인터셉터는 스프링 MVC의 하위 기술이므로 스프링 MVC의 시작점인 디스패처 서블릿 이후에 등장한다스프링 컨테이너 제한HTTP 요청 -&amp;gt; WAS -&amp;gt; 필터 -&amp;gt; 서블릿 -&amp;gt; 스프링 인터셉터 -&amp;gt; 컨트롤러 // 인가 사용자 (로그인 Success)HTTP 요청 -&amp;gt; WAS -&amp;gt; 필터 -&amp;gt; 서블릿 -&amp;gt; 스프링 인터셉터 -&amp;gt; X // 비인가 사용자 (로그인 Fail)스프링 인터셉터 체인스프링 인터셉터도 체인으로 구성되는데, 중간에 필터를 자유롭게 추가할 수 있다예를 들어 로그를 남기는 인터셉터를 먼저 적용하고, 그 다음에 로그인 여부를 체크하는 인터셉터를 만들 수 있다HTTP 요청 -&amp;gt; WAS -&amp;gt; 필터 -&amp;gt; 서블릿 -&amp;gt; 인터셉터1 -&amp;gt; 인터셉터2 -&amp;gt; 인터셉터3 -&amp;gt; 컨트롤러 // 필터 체인스프링 인터셉터 인터페이스스프링 인터셉터를 사용하려면 HandlerInterceptor 인터페이스를 구현하면 된다public interface HandlerInterceptor { default boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {} default void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception {} default void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception {}} preHandle() : 컨트롤러 호출 전(정확히는 핸들러 어댑터 호출 전)에 호출된다 postHandle(): 컨트롤러 호출 후에 호출된다 aftercompletion() : 뷰가 렌더링된 이후 호출된다. 오류가 발생해도 항상 호출된다스프링 인터셉터의 사용서비스 접근 로그를 남기는 필터를 작성하고 적용해 보겠다먼저 로그 필터를 작성해 보자@Slf4jpublic class LogInterceptor implements HandlerInterceptor{ default boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { String requestURI = request.getRequestURI(); String uuid = UUID.randomUUID().toString(); request.setAttribute(LOG_ID, uuid); if (handler instanceof HandlerMethod) { HandlerMethod hm = (HandlerMethod) handler; } log.info(&quot;REQUEST [{}][{}][{}]&quot;, uuid, requestURI, handler); return true; } default void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception { log.info(&quot;postHandle [{}]&quot;, modelAndView); } default void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception { String requestURI = request.getRequestURI(); String logId = (String)request.getAttribute(LOG_ID); log.info(&quot;RESPONSE [{}][{}]&quot;, logId, requestURI); if (ex != null) { log.error(&quot;afterCompletion error!!&quot;, ex); } }}preHandle에서 등록한 값을 postHandle이나 afterCompletion에서 사용하려면 request에 담아두어야 한다이제 작성한 인터셉터를 등록해 보자WebMvcConfigurer 인터셉터를 구현한 WebConfig 클래스를 작성했다@Configurationpublic class WebConfig implements WebMvcConfigurer{ @Override public void addInterceptors(InterceptorRegistry registry){ registry.addInterceptor(new LogInterceptor()) .order(1) .addPathPatterns(&quot;/**&quot;) .excludePathPatterns(&quot;/css/**&quot;, &quot;/*.ico&quot;, &quot;/error&quot;); }}이제 프로그램을 실행하고 이 서비스로 요청을 보내면 console에 Request, Response 로그가 출력될 것이다" }, { "title": "스프링 의존관계 주입 (Dependency Injection)", "url": "/posts/spring-dependency-injection/", "categories": "Spring, Core", "tags": "spring, dependency injection", "date": "2021-09-28 09:00:01 +0900", "snippet": "#의존관계 주입이란?어플리케이션이 실행된 후 사용할 객체들이 생성된다생성된 객체들이 서로를 의존하는 경우 각 객체들의 이름을 모를 뿐더러 주입하는 코드를 작성하기엔 너무 불편하다 따라서 생성된 객체들의 의존관계를 자동으로 설정할 필요가 있는데 이를 구현하는 다양한 방법이 존재한다하나씩 알아보고 어떤 주입을 사용해야 하는지, 더 편하게 사용하는 방법은 없는지 알아보자###1. 생성자 주입public class MemberController{ private final MemberService memberService; @Autowired public MemberController(MemberService memberService){ // 생성자 주입 this.memberService = memberService; }}이름 그대로 생성자를 통해 의존 관계를 주입받는 방법이다생성자는 객체 생성시 한번만 호출되므로 유일성이 보장되므로 유일성을 보장한다는 특징이 있다위와 같이 생성자가 하나만 존재할 경우 @Autowired 어노테이션을 생략할 수 있다###2. setter 주입public class MemberController{ private final MemberService memberService; @Autowired public setMemberService(MemberService memberService){ // setter 주입 (수정자 주입) this.memberService = memberService; }}자바빈 프로퍼티의 수정자 메서드 방식을 사용하는 방식이다setter는 생성 이후에도 사용할 수 있으므로 선택, 변경 가능성이 있는 의존관계에 사용한다###3. 필드 주입public class MemberController{ @Autowired private final MemberService memberService; // 필드 주입}말 그대로 필드에 주입하는 방식이다코드에 직접 주입하기에 매우 간편하지만 외부에서 변경이 불가능해서 테스트가 불가능하다는 단점이 있다###4. 메서드 주입public class MemberController{ private final MemberService memberService; pirvate final LoginService loginService; @Autowired public init(MemberService memberService, LoginService loginService){ // 메서드 주입 this.memberService = memberService; this.loginService = loginService; }}여러 멤버를 한번에 주입받을 수 있지만 잘 사용하지 않는다의존관계 주입 사용 가이드 ###생성자 주입을 선택해라!과거에는 setter 주입과 필드 주입을 많이 사용했지만 최근에는 대부분의 프레임워크가 생성자 주입을 권장한다 그 이유는 다음과 같다####불변대부분의 의존관계는 바뀌지 않는다####접근 제어자setter 주입을 사용하려면 setter메서드의 접근 제어자를 public으로 열어 두어야 한다setter의 접근을 막아야 하는 경우에도 public 설정이 강제된다 ####누락생성자 주입을 사용하면 주입 데이터를 누락했을 때 컴파일 오류가 발생한다컴파일 시점에 오류를 발견할 수 있다는 장점이 있다Lombok을 사용하는 의존관계 주입이제 의존관계 주입에 사용될 방식을 결정했다하지만 필드 주입을 사용하다가 생성자 주입을 사용하려니 여간 불편한 것이 아니다이러한 불편함을 해소하기 위해 Lombok이라는 라이브러리가 존재한다@RequiredArgsConstructorpublic class MemberController{ private final MemberService memberService; pirvate final LoginService loginService;}Lombok의 @RequiredArgsConstructor 어노테이션은 private이 지정된 필드를 모아 생성자를 만들어 준다결과적으로 필드 주입과 같은 형태로 생성자 주입을 사용하는 것이다" }, { "title": "스프링 컨테이너(Container)와 스프링 빈(Bean)", "url": "/posts/spring-conatiner-bean/", "categories": "Spring, Core", "tags": "spring, container, bean", "date": "2021-09-28 09:00:01 +0900", "snippet": "##스프링 컨테이너스프링 컨테이너는 스프링 빈을 관리하는 객체이다스프링 컨테이너는 @Configuration이 붙은 설정 클래스를 설정 정보로 사용한다이 클래스 내부에서 @Bean이 붙은 메서드의 이름으로 컨테이너에 객체를 등록하는데 이를 스프링 빈이라고 한다##스프링 빈스프링 빈은 프로그램 실행 중 사용하기 위해 미리 만들어놓은 객체라고 생각하면 된다##스프링 빈의 생명주기####1. 스프링 컨테이너 생성스프링 컨테이너를 생성할 때에는 구성 정보를 지정해 주어야 한다구성 정보는 class파일, XML파일, Groovy파일 등등 다양한 형식이 지원된다이번 포스팅에선 class파일을 사용한 구성을 사용한다####2. 스프링 빈 등록스프링 부트의 설정파일이 다음과 같다고 하자// AppConfig.class@Configurationpublic class AppConfig{ @Bean public MemberController(){return new MemberController(memberService);} @Bean public MemberService(){return new MemberServiceImpl(memberRepository);} @Bean public MemberRepository(){return new MemberRepository();}}@SpringBootApplication은 위AppConfig.class설정파일을 넘겨받아 스프링 컨테이너를 생성한다ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class);이후 @Bean이 붙은 메서드의 이름으로 스프링 빈을 생성하고 스프링 컨테이너에 등록한다####3. 의존관계 주입이후 등록된 빈에 의존관계를 주입하는데 @Configuration어노테이션을 통해 싱글톤 패턴을 유지하면서 의존성을 주입한다####4. 초기화 콜백초기화 콜백을 지원하는 다양한 방법들이 있지만, 최신 스프링에서 권장하는 방법은 @PostConstruct를 사용하는 것이다####5. 사용####6. 소멸전 콜백초기화 콜백과 동일하게 @PreDestroy 어노테이션을 지원한다####7. 스프링 종료" }, { "title": "객체 지향 설계의 5가지 원칙(OOP, Object Oriented Programming)", "url": "/posts/dictionary/", "categories": "Dictionary", "tags": "dictionary", "date": "2021-09-28 09:00:01 +0900", "snippet": "####절차지향 언어란? 필요에 의해 함수를 만들고 순차적으로 진행하는 방식 대표적으로 C언어가 있다빈 스프링이 IoC방식으로 관리하는 오브젝트빈 팩토리 스프링 IoC를 구현하는 핵심 컨테이너 인터페이스를 말하며 구현체는 Application Context이다애플리케이션 컨텍스트 빈 팩토리를 확장한 IoC 컨테이너컨테이너, IOC 컨테이너 IoC 방식으로 빈을 관리하는 어플리케이션 컨텍스트" }, { "title": "객체 지향 설계 (OOP, Object Oriented Programming)", "url": "/posts/develop-oop/", "categories": "Develop", "tags": "oop", "date": "2021-09-28 09:00:01 +0900", "snippet": "객체 지향 설계란?기술 면접 단골 질문이지만 의외로 바로 대답이 나오지는 않는 질문이다이참에 확실히 정리하고 포스팅을 작성한다 “객체들을 통해 로직을 구성하는 프로그래밍 방법론, 여기서 객체는 추상화된 설계도를 통해 생성되고 상태와 행위를 가진다”객체 지향 설계의 장점###1. 코드 재사용이 용이하다이미 작성된 클래스를 가져와 이용할 수 있고, 상속을 통해 확장할 수 있다###2. 유지보수가 쉽다절차지향 프로그래밍에서는 코드를 수정할 때 로직을 따라가면서 수정해야 하는 반면,객체지향 프로그래밍에서는 수정할 멤버 변수나 메서드만 수정하면 된다###3. 대형 프로젝트에 적합하다클래스단위로 모듈화하여 개발할 수 있으므로 개발 과정에서 업무 분담이 쉽다객체 지향 설계의 단점###1. 처리 속도가 상대적으로 느리다###2. 객체가 많아지면 메모리 사용량이 커진다###3. 설계시 많은 시간과 노력이 필요하다객체 지향 설계 방법론 (SOLID)###1. 단일 책임 원칙 (Single Responsibility Principle)클래스는 하나의 책임만 가져야 한다###2. 개방-폐쇄 원칙 (Open-Closed Principle)확장에는 열려있고 수정에는 닫혀 있어야 한다###3. 리스코프 치환 원칙 (Liskov Substitution Principle)자식 클래스는 부모 클래스의 책임을 무시하거나 재정의하지 않고 확장만 수행해야 한다###4. 인터페이스 분리 원칙 (Interface Segregation Principle)인터페이스는 하나의 책임을 가져야 한다###5. 의존관계 역전 원칙 (Dependency Inversion Principle)구체화가 아닌 추상화에 의존해야 한다구체화에 의존할수록 유지보수성이 떨어진다" }, { "title": "좋은 코드란 무엇일까?", "url": "/posts/what-is-good-code/", "categories": "Develop", "tags": "development, good code", "date": "2021-09-27 09:00:01 +0900", "snippet": "좋은 코드란 무엇일까?좋은 코드란 무엇인가 물어보면 대답하기 어려운 경우가 많다그래서 자료를 찾아보며 하나씩 정리해보려고 한다1.비즈니스 요구사항을 만족하는 코드작성한 코드를 크게 두가지로 분류하면 프로토타입 코드와 지속 가능한 코드로 분류할 수 있다프로토타입 코드는 가독성이 낮고 중복이 많고 많은 오류를 발생시킨다.하지만 빠르게 작성되기에 유지보수 비용이 포기하고 비즈니스 타이밍을 맞출 수 있다다음으로는 지속가능한 코드이다.시스템의 규모가 특정 수준에 이르면 프로토타입 코드는 낮은 가독성과 많은 중복으로 인해 유지보수 비용을 발생시킨다.따라서 좋은 코드는 맥락에 따라 결정된다고 생각할 수 있다.엔지니어링 가치를 추구해야 할 상황이면 지속 가능한 코드를, 비즈니스 타이밍이 중요한 상황이면 프로토타입 코드를 선택해야 할 것이다2. 읽기 쉬운 코드2.1 직관적인 패키지 구조코드가 동작하는 곳과 코드가 정의된 곳 사이의 거리가 멀면 용도를 파악하기 힘들어지고결과적으로 어디에서 쓰는지 모르기 때문에 수정, 사용되지 않는 죽은 코드가 된다2.2 일관성 있는 Naming예를 들어 함수명의 Naming을 정의할 때 convention을 지켜 정의하면 함수를 파악하는데 큰 도움이 된다2.3 파라미터 개수가 최소인 함수파라미터 개수가 많아지면 각각의 역할을 파악하기 힘들어지기 때문에, DTO로 감싸서 코드의 가독성을 높이는 것이 좋다2.4 변경 가능성이 최소화 된 변수와 객체변경 가능성을 최소화하면 물리적으로 불필요한 시간을 줄여줄 수 있고 코드의 유지보수성을 높일 수 있다3. 추적하기 좋은 코드예를 들어 AOP 적용을 고민할 필요가 있다.AOP를 적용하면 중복 로직을 제거하여 깔끔한 코드를 유지할 수 있게 되지만,로직들이 추상화되기 때문에 해당 코드를 추적하기 어렵게 된다" }, { "title": "서블릿 컨테이너와 스프링 컨테이너", "url": "/posts/web-servlet/", "categories": "Spring, Core", "tags": "spring, servlet container, spring container", "date": "2021-09-27 09:00:01 +0900", "snippet": "서블릿 컨테이너란?서블릿은 개발자로 하여금 핵심 비즈니스 로직만 처리할 수 있도록 다양한 기능들을 수행한다이러한 서블릿을 관리하는 서블릿들의 생성, 실행, 파괴, 즉 서블릿의 생명주기를 관리한다 스프링 컨테이너란?스프링 컨테이너는 스프링 빈의 생명주기를 관리한다스프링 빈의 생명주기는 다음과 같다스프링 컨테이너 생성 -&amp;gt; 스프링 빈 생성 -&amp;gt; 의존관계 주입 -&amp;gt; 초기화 콜백 -&amp;gt; 사용 -&amp;gt; 소멸자 콜백 -&amp;gt; 스프링 종료#웹 어플리케이션 동작 원리 웹 어플리케이션이 실행되면 WAS가 web.xml을 로딩한다 web.xml에 등록된 ContextLoaderListener(Java Class)가 생성된다. (ContextLoaderListner는 ApplicationContext를 생성하는 역할을 한다) 생성된 ContextLoaderListener는 root.xml을 로딩힌다 root.xml에 등록된 Spring Container를 생성하고 Spring Bean을 등록, 의존관계를 주입한다 클라이언트로부터 request를 받는다 DispatcherServlet을 생성한다 DispatcherServlet은 servlet-context.xml를 로딩한다 두번째 Spring Container가 구동되며 응답에 맞는 PageController들이 동작한다" }, { "title": "title", "url": "/posts/spring-logging/", "categories": "", "tags": "", "date": "2021-09-27 09:00:01 +0900", "snippet": "" }, { "title": "title", "url": "/posts/java-exception/", "categories": "", "tags": "", "date": "2021-09-27 09:00:01 +0900", "snippet": "" }, { "title": "Java 다형성(Polymorphism)", "url": "/posts/java-polymorphism/", "categories": "Java", "tags": "java, polymorphism", "date": "2021-09-27 09:00:01 +0900", "snippet": "다형성이란?조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있게 하는 것이다Unit을 상속받는 Marin 클래스가 있다고 가정하자public class Unit{ public int hp; public int mp;}public class Marin extends Unit { public void attack(){...}}Unit 참조 변수는 Marin 객체를 가리킬 수 있을까?Unit unit = new Marin(); // OK그렇다. 가리킬 수 있지만 unit을 통해서는 Maring의 멤버들을 사용할 수 없는 것을 주의한다그렇다면 반대로 Marin 참조 변수는 Unit 객체를 가리킬 수 있을까?Marin marin = new Unit(); // Error불가능하다. Marin에 정의된 멤버들은 Unit객체를 통해 접근할 수 없기 때문이다참조변수의 형변환형변환은 참조변수의 타입을 변경하는 것을 말한다여기서 대입된 인스턴스에는 아무런 영향을 미치지 않는다는 것을 이해해야 한다단지 참조변수의 형변환을 통해 참조하고 있는 인스턴스에서 사용할 수 있는 멤버의 개수를 조절할 뿐이다참조변수의 형변환은 () 기호를 통해 적용할 수 있다다운 캐스팅을 할 때 이를 생략할 수 있는 것이고위의 예시는 사실 다음과 같은 것이다Unit unit = (Unit)new Marin();그렇다면 업 캐스팅은 생략이 불가능하다는 것인데 업 캐스팅을 해보면 어떨까?Marin marin = (Marin)new Unit(); // OK컴파일 타임 오류는 발생하지 않는다. 하지만 실행할 경우 ClassCastException이 발생한다원칙상 조상 타입과 자손 타입끼리 형변환이 가능하지만 조상 객체를 다운 캐스팅하면 자손의 멤버를 사용할 수 없기 때문에 에러가 발생했다instanceof 연산자참조변수가 참조하고있는 인스턴스의 실제 타입을 알아보려면 instanceof 연산자를 사용하면 된다조상 타입의 멤버 메서드 중 자손 타입을 사용하는 메서드가 있다면 형변환을 통해 사용하자public class Unit{}public class Marin extends Unit{...}public class Tank extends Unit{...}public doSomething(Unit unit){ if(unit instanceof Marin){ Marin marin = (Marin)unit; ... } else if(unit instanceof Tank){ Tank tank = (Tank)unit; ... }}참조변수와 인스턴스의 연결조상 클래스와 자손 클래스에 동일한 이름의 멤버를 정의했을 때, 호출하면 어떤 결과가 나올까?이는 멤버의 종류와 참조하는 인스턴스의 종류에 따라 다르다결론부터 말하면, 멤버 변수의 경우 참조 변수의 타입을 따라가고, 멤버 함수는 참조하는 인스턴스의 타입을 따라간다" }, { "title": "Java 내부 클래스(Inner Class)", "url": "/posts/java-inner-class/", "categories": "Java", "tags": "java, inner class", "date": "2021-09-27 09:00:01 +0900", "snippet": "내부 클래스란?내부 클래스는 클래스 내부에 선언된 클래스이다내부 클래스를 사용하는 경우 내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근할 수 있으며 코드 복잡성이 줄어든다는 장점이 있다내부 클래스의 종류와 특징|내부 클래스|특징||—|—||인스턴스 클래스(instance class)|외부 클래스의 멤버 변수들과 같은 위치에 선언한다. 주로 외부 클래스의 인스턴스멤버들과 관련된 작업에 사용될 목적으로 선언된다||스태틱 클래스(static class)|외부 클래스의 멤버변수 선언위치에 선언하며, 외부 클래스의 static멤버처럼 다루어진다. 주로 외부 클래스의 static멤버, 특히 static 메서드에 사용될 목적으로 선언된다||지역 클래스(local class)|외부 클래스의 메서드나 초기화블럭 안에 선언하며, 선언 영역에서만 사용될 수 있다||익명 클래스(anonymous class)|클래스의 선언과 생성을 동시에 하는 이름없는 클래스|public class OuterClass{ class InstanceClass{} // 인스턴스 클래스 static class staticClass{} // 스태틱 클래스 void outerMethod(){ class localClass{} // 지역 클래스 }}익명 클래스익명 클래스는 이름이 없다. 클래스의 선언과 생성을 동시에 하기 때문에 재사용이 불가능한 일회용 클래스이다이름이 없기 때문에 생성자도 없으며, 하나의 클래스를 상속받거나 하나의 인터페이스를 구현할 수 있다abstract class Unit{ void doSomething();}Unit unit = new Unit() { void doSomething(){...}}" }, { "title": "Java 추상 클래스(Abstract Class), 인터페이스(Interface)", "url": "/posts/java-abstract-class/", "categories": "Java", "tags": "java, abstract class, abstract method", "date": "2021-09-27 09:00:01 +0900", "snippet": "추상 클래스(Abstract Class)추상 클래스란?추상 클래스는 추상화 정도가 일반 클래스와 인터페이스의 사이에 있는 클래스이다추상 클래스는 추상 메서드를 포함하고 있다는 것을 제외하고 일반 클래스와 전혀 다르지 않다추상 클래스는 단독으로 인스턴스를 생성할 수 없으며 추상 클래스를 상속하여 추상 메서드를 정의해야 사용할 수 있다추상 메서드(Abstract Method)메서드의 선언부만 작성하고 구현부는 작성하지 않은 채로 남겨 둔 것이 추상 메서드이다일반적으로 상속받을 클래스에 따라 메서드의 내용이 달라질 수 있기 때문에 주석을 통해 그 기능만 지정해 놓는다/* to calculate sum of stream type */abstract int calcSum(Stream&amp;lt;?&amp;gt; stream);추상 클래스를 상속받는 메서드는 추상 메서드를 모두 구현해야 한다만약 구현하지 않은 메서드가 존재한다면 자식 클래스도 추상 클래스로 지정해야 한다추상 클래스의 작성상속이 자손 클래스를 만드는데 조상 클래스를 사용하는 것이라고 하면,추상화는 기존 클래스의 공통부분만 뽑아내어 조상 클래스를 만드는 것이라고 할 수 있다추상화 - 클래스간의 공통점을 찾아내어 공통의 조상을 만드는 작업구체화 - 상속을 통해 클래스를 구현, 확장하는 작업추상 클래스의 의미어차피 자손 클래스에서 오버라이딩하여 새로운 함수를 작성할 것이기 때문에 추상 클래스가 필요없어 보일 수 있다하지만 추상 클래스를 지정함으로서 추상 메서드의 오버라이딩을 강제할 수 있다는 장점이 있다인터페이스(Interface)인터페이스란?인터페이스는 일종의 추상클래스이다 인터페이스는 추상클래스처럼 추상메서드를 갖지만 몸통을 갖춘 메서드를 가질 수 없다인터페이스가 가질 수 있는 것은 오직 추상메서드와 상수뿐이다인터페이스의 작성인터페이스의 작성법은 다음과 같다interface 인터페이스 이름{ public static final 타입 상수이름 = 값; public abstract 메서드명(매개변수목록);}인터페이스 작성은 클래스 작성법과 유사하나 몇가지 제한사항이 있다1. 모든 멤버변수는 public static final이어야 하며, 이는 생략이 가능하다2. 모든 메서드는 public abstract 이어야 하며 이는 생략할 수 있다따라서 일반적으로 작성하는 인터페이스는 다음과 같다interface Unit{ int age = 0; // public static final int age = 0; int getAge(); // public abstract int getAge();}원래 인터페이스의 모든 메서드는 추상메서드이어야 하는데,JDK 1.8부터는 static 메서드와 defualt 메서드를 추가하는 방향으로 변경되었다인터페이스의 상속인터페이스는 인터페이스만 상속받을 수 있으며 클래스와 달리 다중상속이 가능하다interface Movable{}interface Attackable{}interface Fightable extends Movable, Attackable{ ...}오버라이딩 할 때는 조상의 메서드보다 넓은 범위의 접근 제어자를 지정해야 한다인터페이스의 추상 메서드는 모두 public abstract이므로 인터페이스를 구현할 때 모두 public으로 지정해야 한다interface Unit{ String name; String getName();}public class Marin implements Unit{ public String getName(){ return this.name; }}인터페이스를 이용한 다중상속두 조상으로부터 상속받는 멤버 중 동일한 이름을 가지거나 동일한 선언부를 가진 메서드가 존재한다고 가정해 보자동일한 이름을 가지기 때문에 두 조상 중 어느 조상으로부터 상속받은 것인지 알 수 없을 것이다따라서 자바에서는 다중 상속을 허용하지 않도록 구현해 놓았다하지만 인터페이스를 사용한다면 다중 상속이 불가능한 것은 아니다TV 클래스와 VCR 클래스를 모두 상속받는 TVCR 클래스를 만들고 싶다고 하자우리는 하나의 클래스를 상속받고 다른 하나는 클래스 내부에 포함시켜 내부적으로 인스턴스를 생성하도록 할 것이다public class Tv{ protected boolean power; public void power(){power = !power;}}public class VCR{ protected int counter; public void play(){...}}먼저 VCR의 상위 인터페이스를 작성해야 한다public interface IVCR{ void play();}TV를 상속받고 VCR을 내부적으로 생성하는 TVCR클래스를 만들자public class TVCR extends TV implements IVCR{ VCR vcr; public TCVR(){ this.vcr = new VCR(); } public void play(){ vcr.play(); }}디폴트 메서드와 static 메서드원래 인터페이스에는 추상 메서드만 선언할 수 있었는데, JDK 1.8부터 디폴트 메서드와 static 메서드가 추가되었다디폴트 메서드클래스에 새로운 메서드를 작성하는 것은 간단하지만, 인터페이스에 메서드를 추가하는 것은 매우 복잡하다이런 경우 디폴트 메서드를 사용하면 해결할 수 있다public interface Interface{ default void defaultMethod(){...};}" }, { "title": "Java 변수(Variables)와 메서드(Method)", "url": "/posts/java-var-and-method/", "categories": "Java", "tags": "java, Variables, Method", "date": "2021-09-25 11:29:30 +0900", "snippet": "선언 위치에 따른 변수의 종류변수는 클래스변수와 인스턴스변수, 지역변수가 있다 변수의 종류 선언위치 생성시기 생성위치 클래스변수 클래스 영역 클래스가 메모리에 올라갈 때 메서드 정의 영역 인스턴스변수 클래스 영역 인스턴스가 생성되었을 때 힙 영역 지역변수 클래스 이외의 영역 변수 선언문이 수행되었을 때 스택 영역 다음은 각 변수의 생성 예시이다public class tmpClass{ int iv; // 인스턴스 변수 static int cv; // 클래스 변수 public tmpClass(){ int lv; // 지역 변수 }}클래스 변수와 인스턴스 변수클래스 변수와 인스턴스 변수를 이해하기 위해 카드 예시를 들어보겠다public class Card{ String type; int val; static int width = 100; static int height = 250;}카드의 공통적인 특성들은 static으로 선언하여 모든 인스턴스가 같은 값을 가지게 하였다기본형 매개변수와 참조형 매개변수메서드 매개변수의 타입이 기본형이면 기본형 값이 복사되고참조형이면 값이 저장된 주소를 읽어온다Student s = new Student(&quot;A&quot;,30);changeIntAge(s.getAge()); // Student의 age 변경되지 않음changeIntegerAge(s.getAge()); // Student의 age 변경됨void changeIntAge(int age){ age=0;}void changeIntegerAge(Integer age){ age = 0;}인스턴스 메서드와 클래스 메서드인스턴스 메서드는 메서드의 작업을 수행하는데 인스턴스 변수를 필요로 하는 메서드이다클래스 메서드는 인스턴스와 관련 없는(인스턴스 변수나 인스턴스 메서드를 사용하지 않는) 메서드이다다음은 인스턴스와 클래스를 사용하는 방법이다 모든 인스턴스에 공통적으로 사용해야하는 것에 static을 붙인다 클래스 변수는 인스턴스를 생성하지 않아도 사용할 수 있다 클래스 메서드는 인스턴스 변수를 사용할 수 없다 메서드 내에서 인스턴스 변수를 사용하지 않는다면 static을 붙이는 것을 고려한다- 클래스의 멤버변수 중 모든 인스턴스에 공통된 값을 유지하는 것이 있다면 static을 붙여준다- 작성 메서드 중 인스턴스 변수나 인스턴스 메서드를 사용하지 않는 메서드에 static을 붙일 것을 고려한다" }, { "title": "Java 스트림(Stream)", "url": "/posts/java-stream/", "categories": "Java", "tags": "java, stream", "date": "2021-09-25 11:29:30 +0900", "snippet": "Stream 이란?데이터 소스의 종류와 무관하게 같은 방식으로 다룰 수 있게 메서드를 정의한 것스트림을 사용한 코드가 간결하고 이해하기 쉬우면서 재사용성이 높다Stream은 데이터 소스를 변경하지 않는다스트림은 데이터 소스를 읽기만 할 뿐 소스를 변경하지 않는다필요하다면 조작한 결과를 컬렉션이나 배열에 담아 반환할 수 있다스트림은 일회용이다스트림은 Iterator처럼 일회용이다스트림을 한번 사용하면 닫혀서 사용할 수 없기 때문에 다시 사용하려면 스트림을 새로 생성해야 한다strStream1.sorted().forEach(System.out::println);int numOfStr - strStream1.count(); // 에러. 스트림이 이미 닫혔음.스트림은 작업을 내부 반복으로 처리한다스트림의 간결함은 내부 반복으로 만들어진다반복문을 메서드의 내부에 숨길 수 있다forEach()는 스트림에 정의된 메서드 중 하나로 매개변수에 대입된 람다식을 모든 요소에 적용한다stream.forEach(System.out::println); // 모든 요소에 대해 println스트림의 연산스트림이 제공하는 연산으로는 중간 연산과 최종 연산이 있다 중간 연산 : 연산 결과가 스트림인 연산, 스트림에 연속해서 중간 연산할 수 있음 최종 연산 : 연산 결과가 스트림이 아닌 연산, 스트림의 요소를 소모하므로 한번만 가능지연된 연산스트림 연산에서 최종 연산이 수행되기 전까지는 중간연산이 수행되지 않는다최종 연산이 수행되어야 비로소 스트림 요소들이 중간 연산을 거쳐 최종 연산에서 소모된다병렬 스트림스트림 만들기스트림의 소스가 될 수 있는 대상은 배열, 컬렉션 등 다양하며 이로부터 스트림을 생성하는 방법을 배울 것이다컬렉션Collection 클래스에 stream()이 정의되어 있다따라서 Collection의 자손들인 List와 Set을 구현한 컬렉션 클래스는 이 메서드로 스트림을 생성할 수 있다Stream&amp;lt;T&amp;gt; Collection.stream()예를 들어 List로부터 스트림을 생성하는 코드는 다음과 같다List&amp;lt;Integer&amp;gt; list = Arrays.asList(1,2,3,4,5);Stream&amp;lt;Integer&amp;gt; intStream = list.stream();배열배열을 소스로 하는 스트림을 생성하는 메서드는 다음과 같이 Stream과 Arrays에 정의되어 있다Stream.of(T... values)Stream.of(T[])Arrays.stream(T[])Arrays.stream(T[] array, int startInclusive, int endExclusive)람다식 - iterate(), generate()iterate 함수는 seed로부터 람다식 f로 의해 계산된 결과를 다시 seed로 하여 계산을 반복한다Stream&amp;lt;Integer&amp;gt; evenStream = Stream.iterate(0, n-&amp;gt;n+2);generate 함수는 iterate 함수와 계산된 결과를 다시 seed로 하지 않는다는 점이 다르다스트림의 중간연산스트림 자르기 - skip(), limit()skip(long n) 함수는 처음 n개의 요소를 건너뛰는 함수이다limit(long maxSize) 함수는 스트림의 요소를 maxSize개로 제한한다IntStream intStream = IntStream.rangeClosed(1, 10);intStream.skip(3).limit(3).forEach(System.out::println); // 345 출력스트림 요소 걸러내기 - filter(), distinct()distinct 함수는 스트림에서 중복된 요소를 제거한다filter 함수는 주어진 조건에 맞지 않는 요소를 걸러낸다IntStream intStream = IntStream.of(1,2,2,3,3,3,4,4,4,4,5,5,5,5,5);intStream.distinct().forEach(System.out::println); // 1,2,3,4,5intStream.filter(i -&amp;gt; i%2==0).forEach(System.out::println); // 2,4정렬스트림을 정렬할 때는 sorted를 사용하면 된다.Stream&amp;lt;T&amp;gt; sorted(Comparator&amp;lt;? super T&amp;gt; comparator)sorted 함수의 매개변수로는 Comparator 뿐만 아니라 람다 함수도 들어갈 수 있다sorted 함수의 매개변수로 Comparator를 사용할 경우 Comparator의 default 메소드와 static 메소드를 사용하면 정렬이 쉬워진다다음은 가장 많이 사용되는 Comparator.comparing 함수와 Comparator.thenComparing 함수의 사용 예시이다studentStream.sorted(Comparator.comparing(Student::getBan) .thenComparing(Student::getTotalScore) .thenComparing(Student::getName)) .forEach(System.out::println); // 학생들을 반, 총점, 이름순으로 정렬Comparator.naturalOrder 함수와 Comparator.reverseOrder 함수는 구현한 Comparator.compareTo 함수를 사용해 정렬한다다음은 naturalOrder를 사용해 정렬한 예시이다public static void main(String[]args){ List&amp;lt;Student&amp;gt; studentList = new ArrayList&amp;lt;&amp;gt;(); studentList.add(new Student(&quot;A&quot;, 30)); studentList.add(new Student(&quot;B&quot;, 20)); studentList.add(new Student(&quot;C&quot;, 10)); studentList.add(new Student(&quot;D&quot;, 20)); studentList.add(new Student(&quot;E&quot;, 30)); studentList.stream().sorted(Comparator.comparing(Student::getAge) .thenComparing(Comparator.naturalOrder())) .forEach(s -&amp;gt; System.out.println(&quot;s.name = &quot; + ((Student)s).name));}static class Student implements Comparable{ String name; Integer age; Integer score; public int compareTo(object o) { return this.name.compareTo(((Student) o).name); }}변환 - map()스트림의 요소들을 특정 형태로 변환해야 할 때 사용한다Stream.map() 함수의 선언부는 다음과 같다Stream&amp;lt;&amp;lt;R&amp;gt; map(Function&amp;lt;? super T, ? extends R&amp;gt; mapper)다음은 Stream을 매개변수로 받아 Stream으로 변환하는 예시이다Stream&amp;lt;String&amp;gt; stringStream = fileStream.map(File::getName);map은 중간 연산이므로 이를 중첩 사용하면 다음과 같이 파일들의 확장자를 출력하는 코드를 작성할 수 있다fileStream.map(File::getName) .filter(s -&amp;gt; s.indexOf(&#39;.&#39;)!=-1) .map(s -&amp;gt; s.subString(s.indexOf(&#39;.&#39;)+1)) .map(s -&amp;gt; s.toUpperCase) .distinct() .forEach(System.out::print);조회 - peek()연산과 연산 사이에 올바르게 처리가 되었는지 확인하기 위해서 peek()를 사용하자forEach와 달리 스트림 요소들을 소모하지 않으므로 연산 사이에 여러 번 끼워 넣어도 문제가 되지 않는다fileStream.map(File::getName) .filter(s -&amp;gt; s.indexOf(&#39;.&#39;)!=-1) .peek(s -&amp;gt; System.out.println(s)) // 확장자가 없는 파일 제외하고 출력 .map(s -&amp;gt; s.subString(s.indexOf(&#39;.&#39;)+1)) .peek(s -&amp;gt; System.out.println(s)) // 확장자만 잘라 출력 .map(s -&amp;gt; s.toUpperCase) .peek(s -&amp;gt; System.out.println(s)) // 확장자를 대문자로 변환해 출력 .distinct() .forEach(System.out::print);기본형 스트림 - mapToInt, mapToLong, mapToDouble기본적으로 스트림 연산은 Stream타입의 스트림을 출력한다 하지만 기본형 요소들을 출력하는 경우 다음과 같이 기본형 스트림을 사용하는 것이 더 편리하다 다음과 같이 학생들의 총점을 더해 출력하는 경우를 생각해보자Stream&amp;lt;Integer&amp;gt; integerStream = studentStream.map(Student::getAge);for (Object o : integerStream.toArray()) { sum += ((Integer) o).intValue();}mapToInt 함수를 사용하면 Integer를 int로 변환할 필요가 없다또한 IntStream과 같은 기본형 스트림은 sum()과 같은 유용한 메서드를 제공한다int sum = studentStream.mapToInt(Student::getAge).sum();int avg = studentStream.mapToInt(Student::getAge).average();이러한 메서드는 모두 최종 연산이므로 연속적인 사용이 불가능하다하지만 이러한 메서드는 같이 사용되는 경우가 많으므로 summaryStatistic() 라는 메서드가 제공된다IntSummaryStatistics stat = studentStream.mapToInt(Student::getAge).summaryStatistics();long totalCount = stat.getCount();long sum = stat.getSum();double avgScore = stat.getAverage();int minScore = stat.getMin();int maxScore = stat.getMax();타입 변환 - flatMap(), toArray()스트림의 요소가 Stream 가 아닌 Stream&amp;lt;T[]&amp;gt; 인 경우, 각 배열의 요소들에 대해 일괄적인 처리를 하기 어렵다 만약 Stream&amp;lt;T[]&amp;gt;에 대해 map(Arrays::stream)을 사용하면, 다음과 같이 Stream&amp;lt;Stream&amp;gt;를 반환한다Stream&amp;lt;String[]&amp;gt; stringArrayStream = Stream.of([&quot;aaa&quot;,&quot;bbb&quot;],[&quot;ccc&quot;,&quot;ddd&quot;],[&quot;eee&quot;,&quot;fff&quot;]);Stream&amp;lt;Stream&amp;lt;String&amp;gt;&amp;gt; stringStreamStream = stringArrayStream.map(Arrays::stream())우리가 원하는 결과는 Stream이므로 이를 얻으려면 flatMap()을 사용해야 한다Stream&amp;lt;String[]&amp;gt; stringArrayStream = Stream.of([&quot;aaa&quot;,&quot;bbb&quot;],[&quot;ccc&quot;,&quot;ddd&quot;],[&quot;eee&quot;,&quot;fff&quot;]);Stream&amp;lt;String&amp;gt; stringStreamStream = stringArrayStream.flatMap(Arrays::stream());Stream 타입을 다시 T[] 타입으로 변환하려면 toArray()메서드를 사용하면 된다 toArray() 메서드의 반환 타입은 Object[]이므로 다음과 같이 생성자를 지정해 주어야 한다String[] stringArray = stringStream.toArray(String::new);" }, { "title": "Java 람다(Lambda)", "url": "/posts/java-lambda/", "categories": "Java", "tags": "java, lambda", "date": "2021-09-25 11:29:30 +0900", "snippet": "람다식자바 5(JDK 1.5)에 추가된 제너릭 이후 가장 큰 변화는 바로 자바 8(JDK 1.8)에 추가된 람다식이다이를 통해 객체지향 언어인 JAVA가 함수형 언어의 특징을 가지게 되었다람다식이란?람다식이란 간단히 메서드를 하나의 식으로 표현한 것이다메서드를 람다식으로 표현하면 메서드의 이름과 반환값이 없어지므로, 람다식을 익명 함수라고도 한다int[] arr = new arr[5];Arrays.setAll(arr, i -&amp;gt; (int)((Math.random()*5)+1)); // 1~5 사이의 정수 5개 저장람다식 작성하기람다식은 메서드의 이름과 반환타입을 제거하고 매개변수 선언부와 몸통 사이에 -&amp;gt; 를 추가한다반환값이 있는 메서드의 경우 return문 대신 식(expression으로 대체할 수 있다)(int a, int b) -&amp;gt; a &amp;gt; b ? a : b또한 매개변수의 타입을 예상할 수 있는 경우 타입의 생략이 가능하다(a, b) -&amp;gt; a &amp;gt; b ? a : b선언된 매개변수가 하나일 경우 괄호도 생략할 수 있다a -&amp;gt; a&amp;gt;0 ? true : false마찬가지로 함수 몸통부의 문장이 하나일 경우 중괄호도 생략이 가능하다함수형 인터페이스자바에서 모든 메서드는 클래스에 포함되어야 한다그렇다면 람다는 어떤 클래스에 포함될까?결론부터 말하면 Object를 구현하는 익명 클래스라고 생각하면 된다함수의 파라미터로 람다식을 요구하는 경우를 많이 보았을 것이다람다식을 받는 클래스를 타고 들어가면 @FunctionalInterface 어노테이션이 붙은 인터페이스를 발견할 수 있다이 인터페이스는 하나의 추상 메서드만 가지는데, 우리는 이를 구현하는 것이다@FunctionalInterfaceinterface MyFunction(){ void myMethod();}람다식을 요구하는 메서드를 작성해 보자public void requireLambda(MyFunction f){ f.myMethod();}MyFunction myFunction = () -&amp;gt; System.out.println(&quot;myFunction&quot;);requireLambda(myFunction);위를 보면 참조변수로 메서드를 주고받는 것 같은 효과를 낼 수 있다하지만 실제로는 익명 클래스의 객체를 주고받는 것을 기억하자java.util.function패키지일반적으로 많이 사용되는 형식의 메서드는 java.util.function패키지에 함수형 인터페이스로 정의해 놓았다 함수형 인터페이스 메서드 설명 java.lang.Runnable void run() 매개변수도 없고 반환값도 없음 Supplier T get() 매개변수는없고 반환값만 있음 Consumer void accept(T t) Supplier와 반대로 반환값이 없고 매개변수만 있음 Function&amp;lt;T,R&amp;gt; R apply(T t) 하나의 매개변수를 받아 하나를 return함 Predicate boolean test(T t) 하나의 매개변수를 받아 boolean을 return함 메서드 참조하나의 메서드만 호출하는 람다식은 ‘클래스이름::메서드이름’ 또는 ‘참조변수::메서드이름’ 으로 바꿀 수 있다" }, { "title": "Java 제너릭스(Generics)", "url": "/posts/java-generic/", "categories": "Java", "tags": "java, comparator, comparable", "date": "2021-09-25 11:29:30 +0900", "snippet": "#제너릭스란?제너릭스란 다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에 컴파일 시의 타입 체크를 해주는 기능이다 객체의 타입을 컴파일 시 체크하기 때문에 객체의 타입 안정성을 높이고 형변환의 번거로움이 줄어든다제너릭스의 장점1. 타입 안정성을 제공한다2. 타입체크와 형변환을 생략할 수 있으므로 코드가 간결해 진다제너릭 클래스의 선언제너릭 타입은 클래스와 메서드에 선언할 수 있는데, 먼저 클래스에 선언하는 제너릭 타입을 알아보자 예를 들어 Box가 다음과 같이 정의되어 있다고 가정하자class Box{ Object item; void setItem(Object item) { this.item = item; } Object getItem() { return item; }}이 클래스를 제너릭으로 선언하면 다음과 같다class Box&amp;lt;T&amp;gt;{ T item; void setItem(T item) { this.item = item; } T getItem() { return item; }}제너릭스의 용어제너릭스에서 사용되는 용어들은 헷갈리기 쉽다. 한번 정리하고 넘어가겠다class Box&amp;lt;T&amp;gt; { }Box : 원시 타입T : 타입 변수Box&amp;lt;T&amp;gt; : 제너릭 클래스, T Box라고 읽는다new Box&amp;lt;T&amp;gt; : 제너릭 타입 호출제너릭스의 제한 제너릭 클래스의 객체를 생성할 때, 객체별로 다른 타입을 가질 수 있지만 클래스 변수는 제너릭 타입을 가질 수 없다클래스 변수는 인스턴스 변수와 무관하게 같은 값을 가져야 하기 때문이다 class Box&amp;lt;T&amp;gt;{ static T item; // 에러 static int compare(T t1, T t2){...}; // 에러} 제너릭 타입의 배열을 생성하는 것도 허용되지 않는다이는 new 연산자 때문인데, 이 연산자는 컴파일 타임에 그 타입을 정확히 알야야 하기 때문이다 class Box&amp;lt;T&amp;gt;{ T[] itemArr; // OK T[] toArray(){ T[] tmpArr = new T[itemArr.length]; // 에러. 제네릭 배열 생성 불가 return tmpArr; }} 제너릭 클래스의 객체 생성과 사용참조변수와 매개변수에 대입된 타입은 같아야 한다두 타입이 상속 관계에 있다고 해도 동일하다Box&amp;lt;Apple&amp;gt; appleBox = new Box&amp;lt;Grape&amp;gt;(); // 에러Box&amp;lt;Fruit&amp;gt; fruitBox = new Box&amp;lt;Apple&amp;gt;(); // 에러단 두 제너릭 클래스가 상속 관계에 있고, 매개변수의 타입이 동일한 경우 대입이 가능하다Box&amp;lt;Apple&amp;gt; appleBox = new FruitBox&amp;lt;Apple&amp;gt;(); // OK생성된 제너릭 클래스의 인스턴스로 자손 관계의 객체는 대입이 가능하다Box&amp;lt;Fruit&amp;gt; fruitBox = new Box&amp;lt;Fruit&amp;gt;;fruitBox.add(new Apple());제한된 제너릭 클래스제너릭 클래스는 하나의 타입만 지정하여 받을 수 있다하지만 제너릭 타입에 extends를 사용하면 특정 타입의 자손들만 대입할 수 있다class FruitBox&amp;lt;T extends Fruit&amp;gt;{} // Fruit의 자손들만 대입 가능Fruit의 자손이면서 Eatable 인터페이스를 구현해야 하면 다음과 같이 &amp;amp;기호를 사용하면 된다class FruitBox&amp;lt;T extends Fruit &amp;amp; Eatable&amp;gt;{}와일드 카드클래스 메서드의 매개변수에는 제너릭 타입 매개변수를 지정할 수 없다따라서 특정 타입을 지정해 주어야 사용할 수 있는데 이 경우 상속 관계의 클래스들도 모두 정의해야 하는 문제점이 있다static Juice makeJuice(FruitBox&amp;lt;Fruit&amp;gt; box){...}static Juice makeJuice(FruitBox&amp;lt;Apple&amp;gt; box){...}하지만 위와 같이 정의해도 메서드 중복 정의 에러가 발생한다이러한 상황에 사용할 수 있는 것이 와일드 카드(?)이다&amp;lt;? extends T&amp;gt; 와일드 카드의 상한 제한&amp;lt;? super T&amp;gt; 와일드 카드의 하한 제한&amp;lt;?&amp;gt; 제한 없음 (= &amp;lt;? extends Object&amp;gt;)이를 적용하면 위 코드를 다음과 같이 바꿀 수 있다static Juice makeJuice(FruitBox&amp;lt;? extends Fruit&amp;gt; box){...}제너릭 타입의 형변환제너릭 타입과 원시 타입의 형변환은 가능할까?Box box = null;Box&amp;lt;T&amp;gt; boxT = null;boxT = (Box&amp;lt;T&amp;gt;)box; // OKbox = (Box)boxT; // OK경고가 발생하긴 하지만 형변환이 가능하다그렇다면 대입된 타입이 다른 두 제너릭 타입끼리의 형변환은 가능할까?Box&amp;lt;Fruit&amp;gt; fruitBox = null;Box&amp;lt;Grape&amp;gt; grapeBox = null;fruitBox = (Box&amp;lt;fruit&amp;gt;)grapeBox; // ErrorgrapeBox = (Box&amp;lt;Grape&amp;gt;)fruitBox; // Error불가능하다. 대입된 타입이 조상 타입이어도 불가능하다그렇다면 Box&amp;lt;? extends Fruit&amp;gt;은 어떨까?Box&amp;lt;? extends Fruit&amp;gt; fruitBox = null;fruitBox = new Box&amp;lt;Apple&amp;gt;(); // OKfruitBox = new Box&amp;lt;Grape&amp;gt;(); // OKBox&amp;lt;Apple&amp;gt; appleBox = null;appleBox = (Box&amp;lt;Apple&amp;gt;)fruitBox; // OK양방향 변환 모두 가능하다그렇다면 와일드카드가 사용된 제너릭 타입끼리는 형변환이 가능할까?Box&amp;lt;? extends String&amp;gt; stringBox = null; // OKBox&amp;lt;? extends Object&amp;gt; objectBox = null; // OKobjectBox = (Box&amp;lt;? extends Object&amp;gt;)stringBox; // OKstringBox = (Box&amp;lt;? extends String&amp;gt;)objectBox; // OK모두 가능하다제너릭 타입의 제거컴파일러는 제너릭 타입을 이용해 소스파일을 체크해 컴파일 시점에 각 타입을 변환한다따라서 class 파일에는 제너릭 타입이 존재하지 않는데 이는 제너릭 이전의 소스 코드와 호환성을 위한 것이다" }, { "title": "Java Comparator와 Comparable", "url": "/posts/java-compare/", "categories": "Java", "tags": "java, comparator, comparable", "date": "2021-09-25 11:29:30 +0900", "snippet": "Comparator와 Comparable두 클래스는 다음과 같은 경우에 사용한다comparator = 기본 정렬기준 외에 다른 기준으로 정렬하고자 할 때 사용comparable = 기본 정렬기준을 구현하는데 사용둘의 return 타입은 모두 int이며 비교대상이 같은 경우 0, 비교값보다 작은 경우 음수, 비교값보다 큰 경우 양수를 반환한다ComparableComparable 인터페이스는 다음과 같이 compareTo 함수를 구현해야 한다public interface Comparable{ int compareTo(Object o);}ComparatorComparator 인터페이스는 다음과 같이 compare 함수를 구현해야 한다public interface Comparator{ int compare(Object o1, Object o2);}다음은 Stream sorted의 파라미터에 들어갈 Comparator 메소드를 구현한 것이다stream.sorted(new Comparator(){ @override public int compare(object o){ return this.o - o; }})" } ]
